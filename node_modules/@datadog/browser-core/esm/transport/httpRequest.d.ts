import type { EndpointBuilder } from '../domain/configuration';
import type { Context } from '../tools/serialisation/context';
import type { RawError } from '../domain/error/error.types';
import { Observable } from '../tools/observable';
/**
 * Use POST request without content type to:
 * - avoid CORS preflight requests
 * - allow usage of sendBeacon
 *
 * multiple elements are sent separated by \n in order
 * to be parsed correctly without content type header
 */
export interface HttpRequest<Body extends Payload = Payload> {
    observable: Observable<HttpRequestEvent<Body>>;
    send(this: void, payload: Body): void;
    sendOnExit(this: void, payload: Body): void;
}
export interface HttpResponse extends Context {
    status: number;
    type?: ResponseType;
}
export interface BandwidthStats {
    ongoingByteCount: number;
    ongoingRequestCount: number;
}
export type HttpRequestEvent<Body extends Payload = Payload> = {
    type: 'failure';
    bandwidth: BandwidthStats;
    payload: Body;
} | {
    type: 'queue-full';
    bandwidth: BandwidthStats;
    payload: Body;
} | {
    type: 'success';
    bandwidth: BandwidthStats;
    payload: Body;
};
export interface Payload {
    data: string | FormData | Blob;
    bytesCount: number;
    retry?: RetryInfo;
    encoding?: 'deflate';
}
export interface RetryInfo {
    count: number;
    lastFailureStatus: number;
}
export declare function createHttpRequest<Body extends Payload = Payload>(endpointBuilder: EndpointBuilder, bytesLimit: number, reportError: (error: RawError) => void): HttpRequest<Body>;
export declare function fetchKeepAliveStrategy(endpointBuilder: EndpointBuilder, bytesLimit: number, payload: Payload, onResponse?: (r: HttpResponse) => void): void;
export declare function fetchStrategy(endpointBuilder: EndpointBuilder, payload: Payload, onResponse?: (r: HttpResponse) => void): void;
