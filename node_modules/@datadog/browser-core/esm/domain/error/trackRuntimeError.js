import { instrumentMethod } from '../../tools/instrumentMethod';
import { Observable } from '../../tools/observable';
import { clocksNow } from '../../tools/utils/timeUtils';
import { computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace';
import { getGlobalObject } from '../../tools/getGlobalObject';
import { computeRawError, isError } from './error';
import { ErrorSource } from './error.types';
export function trackRuntimeError() {
    return new Observable((observer) => {
        const handleRuntimeError = (originalError, stackTrace) => {
            const rawError = computeRawError({
                stackTrace,
                originalError,
                startClocks: clocksNow(),
                nonErrorPrefix: "Uncaught" /* NonErrorPrefix.UNCAUGHT */,
                source: ErrorSource.SOURCE,
                handling: "unhandled" /* ErrorHandling.UNHANDLED */,
            });
            observer.notify(rawError);
        };
        const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError);
        const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError);
        return () => {
            stopInstrumentingOnError();
            stopInstrumentingOnUnhandledRejection();
        };
    });
}
export function instrumentOnError(callback) {
    return instrumentMethod(getGlobalObject(), 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {
        let stackTrace;
        if (!isError(errorObj)) {
            stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column);
        }
        callback(errorObj !== null && errorObj !== void 0 ? errorObj : messageObj, stackTrace);
    });
}
export function instrumentUnhandledRejection(callback) {
    return instrumentMethod(getGlobalObject(), 'onunhandledrejection', ({ parameters: [e] }) => {
        callback(e.reason || 'Empty reason');
    });
}
//# sourceMappingURL=trackRuntimeError.js.map