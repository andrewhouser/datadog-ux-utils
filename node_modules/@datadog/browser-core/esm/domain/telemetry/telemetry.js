import { ConsoleApiName } from '../../tools/display';
import { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error';
import { toStackTraceString } from '../../tools/stackTrace/handlingStack';
import { getExperimentalFeatures } from '../../tools/experimentalFeatures';
import { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../intakeSites';
import { BufferedObservable, Observable } from '../../tools/observable';
import { clocksNow } from '../../tools/utils/timeUtils';
import { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor';
import { sendToExtension } from '../../tools/sendToExtension';
import { performDraw } from '../../tools/utils/numberUtils';
import { jsonStringify } from '../../tools/serialisation/jsonStringify';
import { combine } from '../../tools/mergeInto';
import { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';
import { getConnectivity } from '../connectivity';
import { canUseEventBridge, getEventBridge, startBatchWithReplica } from '../../transport';
import { DISCARDED } from '../../tools/abstractHooks';
import { TelemetryType } from './rawTelemetryEvent.types';
const ALLOWED_FRAME_URLS = [
    'https://www.datadoghq-browser-agent.com',
    'https://www.datad0g-browser-agent.com',
    'https://d3uc069fcn7uxw.cloudfront.net',
    'https://d20xtzwzcl0ceb.cloudfront.net',
    'http://localhost',
    '<anonymous>',
];
const TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];
let telemetryObservable;
export function getTelemetryObservable() {
    if (!telemetryObservable) {
        telemetryObservable = new BufferedObservable(100);
    }
    return telemetryObservable;
}
export function startTelemetry(telemetryService, configuration, hooks, reportError, pageMayExitObservable, createEncoder) {
    const observable = new Observable();
    const { stop } = startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, observable);
    const { enabled } = startTelemetryCollection(telemetryService, configuration, hooks, observable);
    return {
        stop,
        enabled,
    };
}
export function startTelemetryCollection(telemetryService, configuration, hooks, observable) {
    const alreadySentEventsByKind = {};
    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && performDraw(configuration.telemetrySampleRate);
    const telemetryEnabledPerType = {
        [TelemetryType.LOG]: telemetryEnabled,
        [TelemetryType.CONFIGURATION]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),
        [TelemetryType.USAGE]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),
    };
    const runtimeEnvInfo = getRuntimeEnvInfo();
    const telemetryObservable = getTelemetryObservable();
    telemetryObservable.subscribe(({ rawEvent, kind }) => {
        if (!telemetryEnabledPerType[rawEvent.type]) {
            return;
        }
        let alreadySentEvents = alreadySentEventsByKind[kind];
        if (!alreadySentEvents) {
            alreadySentEvents = alreadySentEventsByKind[kind] = new Set();
        }
        if (alreadySentEvents.size >= configuration.maxTelemetryEventsPerPage) {
            return;
        }
        const stringifiedEvent = jsonStringify(rawEvent);
        if (alreadySentEvents.has(stringifiedEvent)) {
            return;
        }
        const defaultTelemetryEventAttributes = hooks.triggerHook(1 /* HookNames.AssembleTelemetry */, {
            startTime: clocksNow().relative,
        });
        if (defaultTelemetryEventAttributes === DISCARDED) {
            return;
        }
        const event = toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo);
        observable.notify(event);
        sendToExtension('telemetry', event);
        alreadySentEvents.add(stringifiedEvent);
    });
    telemetryObservable.unbuffer();
    startMonitorErrorCollection(addTelemetryError);
    return {
        enabled: telemetryEnabled,
    };
    function toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo) {
        const clockNow = clocksNow();
        const event = {
            type: 'telemetry',
            date: clockNow.timeStamp,
            service: telemetryService,
            version: "6.18.0",
            source: 'browser',
            _dd: {
                format_version: 2,
            },
            telemetry: combine(rawEvent, {
                runtime_env: runtimeEnvInfo,
                connectivity: getConnectivity(),
                sdk_setup: "npm",
            }),
            experimental_features: Array.from(getExperimentalFeatures()),
        };
        return combine(event, defaultTelemetryEventAttributes);
    }
}
function startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, telemetryObservable) {
    const cleanupTasks = [];
    if (canUseEventBridge()) {
        const bridge = getEventBridge();
        const telemetrySubscription = telemetryObservable.subscribe((event) => bridge.send('internal_telemetry', event));
        cleanupTasks.push(() => telemetrySubscription.unsubscribe());
    }
    else {
        const telemetryBatch = startBatchWithReplica(configuration, {
            endpoint: configuration.rumEndpointBuilder,
            encoder: createEncoder(4 /* DeflateEncoderStreamId.TELEMETRY */),
        }, configuration.replica && {
            endpoint: configuration.replica.rumEndpointBuilder,
            encoder: createEncoder(5 /* DeflateEncoderStreamId.TELEMETRY_REPLICA */),
        }, reportError, pageMayExitObservable, 
        // We don't use an actual session expire observable here, to make telemetry collection
        // independent of the session. This allows to start and send telemetry events ealier.
        new Observable());
        cleanupTasks.push(() => telemetryBatch.stop());
        const telemetrySubscription = telemetryObservable.subscribe((event) => {
            telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration));
        });
        cleanupTasks.push(() => telemetrySubscription.unsubscribe());
    }
    return {
        stop: () => cleanupTasks.forEach((task) => task()),
    };
}
function getRuntimeEnvInfo() {
    return {
        is_local_file: window.location.protocol === 'file:',
        is_worker: 'WorkerGlobalScope' in self,
    };
}
export function resetTelemetry() {
    telemetryObservable = undefined;
}
/**
 * Avoid mixing telemetry events from different data centers
 * but keep replicating staging events for reliability
 */
export function isTelemetryReplicationAllowed(configuration) {
    return configuration.site === INTAKE_SITE_STAGING;
}
export function addTelemetryDebug(message, context) {
    displayIfDebugEnabled(ConsoleApiName.debug, message, context);
    getTelemetryObservable().notify({
        rawEvent: {
            type: TelemetryType.LOG,
            message,
            status: "debug" /* StatusType.debug */,
            ...context,
        },
        kind: "debug" /* StatusType.debug */,
    });
}
export function addTelemetryError(e, context) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: TelemetryType.LOG,
            status: "error" /* StatusType.error */,
            ...formatError(e),
            ...context,
        },
        kind: "error" /* StatusType.error */,
    });
}
export function addTelemetryConfiguration(configuration) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: TelemetryType.CONFIGURATION,
            configuration,
        },
        kind: TelemetryType.CONFIGURATION,
    });
}
export function addTelemetryMetrics(kind, context) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: TelemetryType.LOG,
            message: kind,
            status: "debug" /* StatusType.debug */,
            ...context,
        },
        kind,
    });
}
export function addTelemetryUsage(usage) {
    getTelemetryObservable().notify({
        rawEvent: {
            type: TelemetryType.USAGE,
            usage,
        },
        kind: TelemetryType.USAGE,
    });
}
export function formatError(e) {
    if (isError(e)) {
        const stackTrace = computeStackTrace(e);
        return {
            error: {
                kind: stackTrace.name,
                stack: toStackTraceString(scrubCustomerFrames(stackTrace)),
            },
            message: stackTrace.message,
        };
    }
    return {
        error: {
            stack: NO_ERROR_STACK_PRESENT_MESSAGE,
        },
        message: `${"Uncaught" /* NonErrorPrefix.UNCAUGHT */} ${jsonStringify(e)}`,
    };
}
export function scrubCustomerFrames(stackTrace) {
    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));
    return stackTrace;
}
//# sourceMappingURL=telemetry.js.map