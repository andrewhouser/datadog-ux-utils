import { combine } from './mergeInto';
// Discards the event from being sent
export const DISCARDED = 'DISCARDED';
// Skips from the assembly of the event
export const SKIPPED = 'SKIPPED';
export function abstractHooks() {
    const callbacks = {};
    return {
        register(hookName, callback) {
            if (!callbacks[hookName]) {
                callbacks[hookName] = [];
            }
            callbacks[hookName].push(callback);
            return {
                unregister: () => {
                    callbacks[hookName] = callbacks[hookName].filter((cb) => cb !== callback);
                },
            };
        },
        triggerHook(hookName, param) {
            const hookCallbacks = callbacks[hookName] || [];
            const results = [];
            for (const callback of hookCallbacks) {
                const result = callback(param);
                if (result === DISCARDED) {
                    return DISCARDED;
                }
                if (result === SKIPPED) {
                    continue;
                }
                results.push(result);
            }
            return combine(...results);
        },
    };
}
//# sourceMappingURL=abstractHooks.js.map