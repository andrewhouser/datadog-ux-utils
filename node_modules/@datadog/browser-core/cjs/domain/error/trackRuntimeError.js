"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackRuntimeError = trackRuntimeError;
exports.instrumentOnError = instrumentOnError;
exports.instrumentUnhandledRejection = instrumentUnhandledRejection;
const instrumentMethod_1 = require("../../tools/instrumentMethod");
const observable_1 = require("../../tools/observable");
const timeUtils_1 = require("../../tools/utils/timeUtils");
const computeStackTrace_1 = require("../../tools/stackTrace/computeStackTrace");
const getGlobalObject_1 = require("../../tools/getGlobalObject");
const error_1 = require("./error");
const error_types_1 = require("./error.types");
function trackRuntimeError() {
    return new observable_1.Observable((observer) => {
        const handleRuntimeError = (originalError, stackTrace) => {
            const rawError = (0, error_1.computeRawError)({
                stackTrace,
                originalError,
                startClocks: (0, timeUtils_1.clocksNow)(),
                nonErrorPrefix: "Uncaught" /* NonErrorPrefix.UNCAUGHT */,
                source: error_types_1.ErrorSource.SOURCE,
                handling: "unhandled" /* ErrorHandling.UNHANDLED */,
            });
            observer.notify(rawError);
        };
        const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError);
        const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError);
        return () => {
            stopInstrumentingOnError();
            stopInstrumentingOnUnhandledRejection();
        };
    });
}
function instrumentOnError(callback) {
    return (0, instrumentMethod_1.instrumentMethod)((0, getGlobalObject_1.getGlobalObject)(), 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {
        let stackTrace;
        if (!(0, error_1.isError)(errorObj)) {
            stackTrace = (0, computeStackTrace_1.computeStackTraceFromOnErrorMessage)(messageObj, url, line, column);
        }
        callback(errorObj !== null && errorObj !== void 0 ? errorObj : messageObj, stackTrace);
    });
}
function instrumentUnhandledRejection(callback) {
    return (0, instrumentMethod_1.instrumentMethod)((0, getGlobalObject_1.getGlobalObject)(), 'onunhandledrejection', ({ parameters: [e] }) => {
        callback(e.reason || 'Empty reason');
    });
}
//# sourceMappingURL=trackRuntimeError.js.map