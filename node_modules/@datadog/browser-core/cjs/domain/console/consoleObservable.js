"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initConsoleObservable = initConsoleObservable;
exports.resetConsoleObservable = resetConsoleObservable;
const error_1 = require("../error/error");
const observable_1 = require("../../tools/observable");
const display_1 = require("../../tools/display");
const monitor_1 = require("../../tools/monitor");
const sanitize_1 = require("../../tools/serialisation/sanitize");
const jsonStringify_1 = require("../../tools/serialisation/jsonStringify");
const error_types_1 = require("../error/error.types");
const computeStackTrace_1 = require("../../tools/stackTrace/computeStackTrace");
const handlingStack_1 = require("../../tools/stackTrace/handlingStack");
const timeUtils_1 = require("../../tools/utils/timeUtils");
let consoleObservablesByApi = {};
function initConsoleObservable(apis) {
    const consoleObservables = apis.map((api) => {
        if (!consoleObservablesByApi[api]) {
            consoleObservablesByApi[api] = createConsoleObservable(api); // we are sure that the observable created for this api will yield the expected ConsoleLog type
        }
        return consoleObservablesByApi[api];
    });
    return (0, observable_1.mergeObservables)(...consoleObservables);
}
function resetConsoleObservable() {
    consoleObservablesByApi = {};
}
function createConsoleObservable(api) {
    return new observable_1.Observable((observable) => {
        const originalConsoleApi = display_1.globalConsole[api];
        display_1.globalConsole[api] = (...params) => {
            originalConsoleApi.apply(console, params);
            const handlingStack = (0, handlingStack_1.createHandlingStack)('console error');
            (0, monitor_1.callMonitored)(() => {
                observable.notify(buildConsoleLog(params, api, handlingStack));
            });
        };
        return () => {
            display_1.globalConsole[api] = originalConsoleApi;
        };
    });
}
function buildConsoleLog(params, api, handlingStack) {
    const message = params.map((param) => formatConsoleParameters(param)).join(' ');
    if (api === display_1.ConsoleApiName.error) {
        const firstErrorParam = params.find(error_1.isError);
        const rawError = (0, error_1.computeRawError)({
            originalError: firstErrorParam,
            handlingStack,
            startClocks: (0, timeUtils_1.clocksNow)(),
            source: error_types_1.ErrorSource.CONSOLE,
            handling: "handled" /* ErrorHandling.HANDLED */,
            nonErrorPrefix: "Provided" /* NonErrorPrefix.PROVIDED */,
            // if no good stack is computed from the error, let's not use the fallback stack message
            // advising the user to use an instance of Error, as console.error is commonly used without an
            // Error instance.
            useFallbackStack: false,
        });
        // Use the full log message as the error message instead of just the error instance message.
        rawError.message = message;
        return {
            api,
            message,
            handlingStack,
            error: rawError,
        };
    }
    return {
        api,
        message,
        error: undefined,
        handlingStack,
    };
}
function formatConsoleParameters(param) {
    if (typeof param === 'string') {
        return (0, sanitize_1.sanitize)(param);
    }
    if ((0, error_1.isError)(param)) {
        return (0, handlingStack_1.formatErrorMessage)((0, computeStackTrace_1.computeStackTrace)(param));
    }
    return (0, jsonStringify_1.jsonStringify)((0, sanitize_1.sanitize)(param), undefined, 2);
}
//# sourceMappingURL=consoleObservable.js.map