"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpRequest = createHttpRequest;
exports.fetchKeepAliveStrategy = fetchKeepAliveStrategy;
exports.fetchStrategy = fetchStrategy;
const monitor_1 = require("../tools/monitor");
const observable_1 = require("../tools/observable");
const sendWithRetryStrategy_1 = require("./sendWithRetryStrategy");
function createHttpRequest(endpointBuilder, bytesLimit, reportError) {
    const observable = new observable_1.Observable();
    const retryState = (0, sendWithRetryStrategy_1.newRetryState)();
    const sendStrategyForRetry = (payload, onResponse) => fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
    return {
        observable,
        send: (payload) => {
            (0, sendWithRetryStrategy_1.sendWithRetryStrategy)(payload, retryState, sendStrategyForRetry, endpointBuilder.trackType, reportError, observable);
        },
        /**
         * Since fetch keepalive behaves like regular fetch on Firefox,
         * keep using sendBeaconStrategy on exit
         */
        sendOnExit: (payload) => {
            sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
        },
    };
}
function sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {
    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;
    if (canUseBeacon) {
        try {
            const beaconUrl = endpointBuilder.build('beacon', payload);
            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);
            if (isQueued) {
                return;
            }
        }
        catch (e) {
            reportBeaconError(e);
        }
    }
    fetchStrategy(endpointBuilder, payload);
}
let hasReportedBeaconError = false;
function reportBeaconError(e) {
    if (!hasReportedBeaconError) {
        hasReportedBeaconError = true;
        (0, monitor_1.monitorError)(e);
    }
}
function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {
    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;
    if (canUseKeepAlive) {
        const fetchUrl = endpointBuilder.build('fetch-keepalive', payload);
        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' })
            .then((0, monitor_1.monitor)((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
            .catch((0, monitor_1.monitor)(() => fetchStrategy(endpointBuilder, payload, onResponse)));
    }
    else {
        fetchStrategy(endpointBuilder, payload, onResponse);
    }
}
function fetchStrategy(endpointBuilder, payload, onResponse) {
    const fetchUrl = endpointBuilder.build('fetch', payload);
    fetch(fetchUrl, { method: 'POST', body: payload.data, mode: 'cors' })
        .then((0, monitor_1.monitor)((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))
        .catch((0, monitor_1.monitor)(() => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: 0 })));
}
function isKeepAliveSupported() {
    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors
    try {
        return window.Request && 'keepalive' in new Request('http://a');
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=httpRequest.js.map