"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startLogsAssembly = startLogsAssembly;
const browser_core_1 = require("@datadog/browser-core");
const logger_1 = require("./logger");
function startLogsAssembly(configuration, lifeCycle, hooks, getCommonContext, reportError) {
    const statusWithCustom = logger_1.STATUSES.concat(['custom']);
    const logRateLimiters = {};
    statusWithCustom.forEach((status) => {
        logRateLimiters[status] = (0, browser_core_1.createEventRateLimiter)(status, configuration.eventRateLimiterThreshold, reportError);
    });
    lifeCycle.subscribe(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, domainContext, ddtags = [] }) => {
        var _a, _b;
        const startTime = (0, browser_core_1.getRelativeTime)(rawLogsEvent.date);
        const commonContext = savedCommonContext || getCommonContext();
        const defaultLogsEventAttributes = hooks.triggerHook(0 /* HookNames.Assemble */, {
            startTime,
        });
        if (defaultLogsEventAttributes === browser_core_1.DISCARDED) {
            return;
        }
        const defaultDdtags = (0, browser_core_1.buildTags)(configuration);
        const log = (0, browser_core_1.combine)({
            view: commonContext.view,
        }, defaultLogsEventAttributes, rawLogsEvent, messageContext, {
            ddtags: defaultDdtags.concat(ddtags).join(','),
        });
        if (((_a = configuration.beforeSend) === null || _a === void 0 ? void 0 : _a.call(configuration, log, domainContext)) === false ||
            (log.origin !== browser_core_1.ErrorSource.AGENT &&
                ((_b = logRateLimiters[log.status]) !== null && _b !== void 0 ? _b : logRateLimiters['custom']).isLimitReached())) {
            return;
        }
        lifeCycle.notify(1 /* LifeCycleEventType.LOG_COLLECTED */, log);
    });
}
//# sourceMappingURL=assembly.js.map