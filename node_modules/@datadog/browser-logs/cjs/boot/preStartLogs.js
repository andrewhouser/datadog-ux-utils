"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPreStartStrategy = createPreStartStrategy;
const browser_core_1 = require("@datadog/browser-core");
const configuration_1 = require("../domain/configuration");
function createPreStartStrategy(getCommonContext, trackingConsentState, doStartLogs) {
    const bufferApiCalls = (0, browser_core_1.createBoundedBuffer)();
    // TODO next major: remove the globalContext, accountContextManager, userContext from preStartStrategy and use an empty context instead
    const globalContext = (0, browser_core_1.buildGlobalContextManager)();
    (0, browser_core_1.bufferContextCalls)(globalContext, browser_core_1.CustomerContextKey.globalContext, bufferApiCalls);
    const accountContext = (0, browser_core_1.buildAccountContextManager)();
    (0, browser_core_1.bufferContextCalls)(accountContext, browser_core_1.CustomerContextKey.accountContext, bufferApiCalls);
    const userContext = (0, browser_core_1.buildUserContextManager)();
    (0, browser_core_1.bufferContextCalls)(userContext, browser_core_1.CustomerContextKey.userContext, bufferApiCalls);
    let cachedInitConfiguration;
    let cachedConfiguration;
    const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartLogs);
    function tryStartLogs() {
        if (!cachedConfiguration || !cachedInitConfiguration || !trackingConsentState.isGranted()) {
            return;
        }
        trackingConsentStateSubscription.unsubscribe();
        const startLogsResult = doStartLogs(cachedInitConfiguration, cachedConfiguration);
        bufferApiCalls.drain(startLogsResult);
    }
    return {
        init(initConfiguration) {
            if (!initConfiguration) {
                browser_core_1.display.error('Missing configuration');
                return;
            }
            // Set the experimental feature flags as early as possible, so we can use them in most places
            (0, browser_core_1.initFeatureFlags)(initConfiguration.enableExperimentalFeatures);
            if ((0, browser_core_1.canUseEventBridge)()) {
                initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
            }
            // Expose the initial configuration regardless of initialization success.
            cachedInitConfiguration = initConfiguration;
            (0, browser_core_1.addTelemetryConfiguration)((0, configuration_1.serializeLogsConfiguration)(initConfiguration));
            if (cachedConfiguration) {
                (0, browser_core_1.displayAlreadyInitializedError)('DD_LOGS', initConfiguration);
                return;
            }
            const configuration = (0, configuration_1.validateAndBuildLogsConfiguration)(initConfiguration);
            if (!configuration) {
                return;
            }
            cachedConfiguration = configuration;
            // Instrumuent fetch to track network requests
            // This is needed in case the consent is not granted and some cutsomer
            // library (Apollo Client) is storing uninstrumented fetch to be used later
            // The subscrption is needed so that the instrumentation process is completed
            (0, browser_core_1.initFetchObservable)().subscribe(browser_core_1.noop);
            trackingConsentState.tryToInit(configuration.trackingConsent);
            tryStartLogs();
        },
        get initConfiguration() {
            return cachedInitConfiguration;
        },
        globalContext,
        accountContext,
        userContext,
        getInternalContext: browser_core_1.noop,
        handleLog(message, statusType, handlingStack, context = getCommonContext(), date = (0, browser_core_1.timeStampNow)()) {
            bufferApiCalls.add((startLogsResult) => startLogsResult.handleLog(message, statusType, handlingStack, context, date));
        },
    };
}
function overrideInitConfigurationForBridge(initConfiguration) {
    return { ...initConfiguration, clientToken: 'empty' };
}
//# sourceMappingURL=preStartLogs.js.map