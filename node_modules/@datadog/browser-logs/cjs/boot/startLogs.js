"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startLogs = startLogs;
const browser_core_1 = require("@datadog/browser-core");
const logsSessionManager_1 = require("../domain/logsSessionManager");
const assembly_1 = require("../domain/assembly");
const consoleCollection_1 = require("../domain/console/consoleCollection");
const reportCollection_1 = require("../domain/report/reportCollection");
const networkErrorCollection_1 = require("../domain/networkError/networkErrorCollection");
const runtimeErrorCollection_1 = require("../domain/runtimeError/runtimeErrorCollection");
const lifeCycle_1 = require("../domain/lifeCycle");
const loggerCollection_1 = require("../domain/logger/loggerCollection");
const startLogsBatch_1 = require("../transport/startLogsBatch");
const startLogsBridge_1 = require("../transport/startLogsBridge");
const internalContext_1 = require("../domain/contexts/internalContext");
const reportError_1 = require("../domain/reportError");
const hooks_1 = require("../domain/hooks");
const rumInternalContext_1 = require("../domain/contexts/rumInternalContext");
const sessionContext_1 = require("../domain/contexts/sessionContext");
const trackingConsentContext_1 = require("../domain/contexts/trackingConsentContext");
const LOGS_STORAGE_KEY = 'logs';
function startLogs(configuration, getCommonContext, 
// `startLogs` and its subcomponents assume tracking consent is granted initially and starts
// collecting logs unconditionally. As such, `startLogs` should be called with a
// `trackingConsentState` set to "granted".
trackingConsentState, bufferedDataObservable) {
    const lifeCycle = new lifeCycle_1.LifeCycle();
    const hooks = (0, hooks_1.createHooks)();
    const cleanupTasks = [];
    lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, (log) => (0, browser_core_1.sendToExtension)('logs', log));
    const reportError = (0, reportError_1.startReportError)(lifeCycle);
    const pageMayExitObservable = (0, browser_core_1.createPageMayExitObservable)(configuration);
    const telemetry = (0, browser_core_1.startTelemetry)("browser-logs-sdk" /* TelemetryService.LOGS */, configuration, hooks, reportError, pageMayExitObservable, browser_core_1.createIdentityEncoder);
    cleanupTasks.push(telemetry.stop);
    const session = configuration.sessionStoreStrategyType && !(0, browser_core_1.canUseEventBridge)() && !(0, browser_core_1.willSyntheticsInjectRum)()
        ? (0, logsSessionManager_1.startLogsSessionManager)(configuration, trackingConsentState)
        : (0, logsSessionManager_1.startLogsSessionManagerStub)(configuration);
    (0, trackingConsentContext_1.startTrackingConsentContext)(hooks, trackingConsentState);
    // Start user and account context first to allow overrides from global context
    (0, sessionContext_1.startSessionContext)(hooks, configuration, session);
    const accountContext = (0, browser_core_1.startAccountContext)(hooks, configuration, LOGS_STORAGE_KEY);
    const userContext = (0, browser_core_1.startUserContext)(hooks, configuration, session, LOGS_STORAGE_KEY);
    const globalContext = (0, browser_core_1.startGlobalContext)(hooks, configuration, LOGS_STORAGE_KEY, false);
    const { stop } = (0, rumInternalContext_1.startRUMInternalContext)(hooks);
    (0, networkErrorCollection_1.startNetworkErrorCollection)(configuration, lifeCycle);
    (0, runtimeErrorCollection_1.startRuntimeErrorCollection)(configuration, lifeCycle, bufferedDataObservable);
    bufferedDataObservable.unbuffer();
    (0, consoleCollection_1.startConsoleCollection)(configuration, lifeCycle);
    (0, reportCollection_1.startReportCollection)(configuration, lifeCycle);
    const { handleLog } = (0, loggerCollection_1.startLoggerCollection)(lifeCycle);
    (0, assembly_1.startLogsAssembly)(configuration, lifeCycle, hooks, getCommonContext, reportError);
    if (!(0, browser_core_1.canUseEventBridge)()) {
        const { stop: stopLogsBatch } = (0, startLogsBatch_1.startLogsBatch)(configuration, lifeCycle, reportError, pageMayExitObservable, session);
        cleanupTasks.push(() => stopLogsBatch());
    }
    else {
        (0, startLogsBridge_1.startLogsBridge)(lifeCycle);
    }
    const internalContext = (0, internalContext_1.startInternalContext)(session);
    return {
        handleLog,
        getInternalContext: internalContext.get,
        accountContext,
        globalContext,
        userContext,
        stop: () => {
            cleanupTasks.forEach((task) => task());
            stop();
        },
    };
}
//# sourceMappingURL=startLogs.js.map