"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disableLongTaskRegistry = disableLongTaskRegistry;
exports.setLongTaskId = setLongTaskId;
exports.getLongTaskId = getLongTaskId;
exports.cleanupLongTaskRegistryAfterCollection = cleanupLongTaskRegistryAfterCollection;
// Maps PerformanceEntry start-time to the corresponding long task id (from RUM LongTaskEvent),
// We need this to link RUM Long Tasks with RUM Profiler stack traces
// Given that long task takes at least 50ms and we export profile at least every 60 seconds, we can have up to 1200 entries (60s / 50ms = 1200).
const registry = new Map();
function disableLongTaskRegistry() {
    registry.clear(); // Free-up the memory
}
/**
 * Store the long task ID in the registry for the Profiler to link it with the corresponding Profile.
 */
function setLongTaskId(longTaskId, startTime) {
    registry.set(startTime, longTaskId);
}
function getLongTaskId(startTime) {
    return registry.get(startTime);
}
/**
 * Delete the Long Task from the registry once we have collected it.
 *
 * @param collectionRelativeTime - The relative time of the collection
 */
function cleanupLongTaskRegistryAfterCollection(collectionRelativeTime) {
    for (const performanceStartTime of registry.keys()) {
        if (performanceStartTime < collectionRelativeTime) {
            // We collected this Long Task already, no need to keep it in the registry.
            registry.delete(performanceStartTime);
        }
    }
}
//# sourceMappingURL=longTaskRegistry.js.map