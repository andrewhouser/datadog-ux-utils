"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackStyleSheet = trackStyleSheet;
exports.getPathToNestedCSSRule = getPathToNestedCSSRule;
const browser_core_1 = require("@datadog/browser-core");
const types_1 = require("../../../types");
const serialization_1 = require("../serialization");
const assembly_1 = require("../assembly");
function trackStyleSheet(styleSheetCb) {
    function checkStyleSheetAndCallback(styleSheet, callback) {
        if (styleSheet && (0, serialization_1.hasSerializedNode)(styleSheet.ownerNode)) {
            callback((0, serialization_1.getSerializedNodeId)(styleSheet.ownerNode));
        }
    }
    const instrumentationStoppers = [
        (0, browser_core_1.instrumentMethod)(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {
            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb((0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.StyleSheetRule, {
                id,
                adds: [{ rule, index }],
            })));
        }),
        (0, browser_core_1.instrumentMethod)(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {
            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb((0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.StyleSheetRule, {
                id,
                removes: [{ index }],
            })));
        }),
    ];
    if (typeof CSSGroupingRule !== 'undefined') {
        instrumentGroupingCSSRuleClass(CSSGroupingRule);
    }
    else {
        instrumentGroupingCSSRuleClass(CSSMediaRule);
        instrumentGroupingCSSRuleClass(CSSSupportsRule);
    }
    function instrumentGroupingCSSRuleClass(cls) {
        instrumentationStoppers.push((0, browser_core_1.instrumentMethod)(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {
            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {
                const path = getPathToNestedCSSRule(styleSheet);
                if (path) {
                    path.push(index || 0);
                    styleSheetCb((0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.StyleSheetRule, {
                        id,
                        adds: [{ rule, index: path }],
                    }));
                }
            });
        }), (0, browser_core_1.instrumentMethod)(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {
            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {
                const path = getPathToNestedCSSRule(styleSheet);
                if (path) {
                    path.push(index);
                    styleSheetCb((0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.StyleSheetRule, {
                        id,
                        removes: [{ index: path }],
                    }));
                }
            });
        }));
    }
    return {
        stop: () => {
            instrumentationStoppers.forEach((stopper) => stopper.stop());
        },
    };
}
function getPathToNestedCSSRule(rule) {
    const path = [];
    let currentRule = rule;
    while (currentRule.parentRule) {
        const rules = Array.from(currentRule.parentRule.cssRules);
        const index = rules.indexOf(currentRule);
        path.unshift(index);
        currentRule = currentRule.parentRule;
    }
    // A rule may not be attached to a stylesheet
    if (!currentRule.parentStyleSheet) {
        return;
    }
    const rules = Array.from(currentRule.parentStyleSheet.cssRules);
    const index = rules.indexOf(currentRule);
    path.unshift(index);
    return path;
}
//# sourceMappingURL=trackStyleSheet.js.map