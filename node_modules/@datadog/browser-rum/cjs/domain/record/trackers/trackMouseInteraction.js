"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackMouseInteraction = trackMouseInteraction;
const browser_core_1 = require("@datadog/browser-core");
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const types_1 = require("../../../types");
const assembly_1 = require("../assembly");
const eventsUtils_1 = require("../eventsUtils");
const serialization_1 = require("../serialization");
const trackMove_1 = require("./trackMove");
const eventTypeToMouseInteraction = {
    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This
    // allows to reference such records from Frustration records.
    //
    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records
    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace
    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to
    // convey such interaction. This would cleanly solve the issue since we would have
    // `PointerInteraction/Up` records that we could reference from `Frustration` records.
    ["pointerup" /* DOM_EVENT.POINTER_UP */]: types_1.MouseInteractionType.MouseUp,
    ["mousedown" /* DOM_EVENT.MOUSE_DOWN */]: types_1.MouseInteractionType.MouseDown,
    ["click" /* DOM_EVENT.CLICK */]: types_1.MouseInteractionType.Click,
    ["contextmenu" /* DOM_EVENT.CONTEXT_MENU */]: types_1.MouseInteractionType.ContextMenu,
    ["dblclick" /* DOM_EVENT.DBL_CLICK */]: types_1.MouseInteractionType.DblClick,
    ["focus" /* DOM_EVENT.FOCUS */]: types_1.MouseInteractionType.Focus,
    ["blur" /* DOM_EVENT.BLUR */]: types_1.MouseInteractionType.Blur,
    ["touchstart" /* DOM_EVENT.TOUCH_START */]: types_1.MouseInteractionType.TouchStart,
    ["touchend" /* DOM_EVENT.TOUCH_END */]: types_1.MouseInteractionType.TouchEnd,
};
function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {
    const handler = (event) => {
        const target = (0, eventsUtils_1.getEventTarget)(event);
        if ((0, browser_rum_core_1.getNodePrivacyLevel)(target, configuration.defaultPrivacyLevel) === browser_rum_core_1.NodePrivacyLevel.HIDDEN ||
            !(0, serialization_1.hasSerializedNode)(target)) {
            return;
        }
        const id = (0, serialization_1.getSerializedNodeId)(target);
        const type = eventTypeToMouseInteraction[event.type];
        let interaction;
        if (type !== types_1.MouseInteractionType.Blur && type !== types_1.MouseInteractionType.Focus) {
            const coordinates = (0, trackMove_1.tryToComputeCoordinates)(event);
            if (!coordinates) {
                return;
            }
            interaction = { id, type, x: coordinates.x, y: coordinates.y };
        }
        else {
            interaction = { id, type };
        }
        const record = {
            id: recordIds.getIdForEvent(event),
            ...(0, assembly_1.assembleIncrementalSnapshot)(types_1.IncrementalSource.MouseInteraction, interaction),
        };
        mouseInteractionCb(record);
    };
    return (0, browser_core_1.addEventListeners)(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {
        capture: true,
        passive: true,
    });
}
//# sourceMappingURL=trackMouseInteraction.js.map