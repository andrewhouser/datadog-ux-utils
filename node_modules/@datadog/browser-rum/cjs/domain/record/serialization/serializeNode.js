"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeNodeWithId = serializeNodeWithId;
exports.generateNextId = generateNextId;
exports.serializeChildNodes = serializeChildNodes;
exports.serializeDocumentNode = serializeDocumentNode;
const browser_rum_core_1 = require("@datadog/browser-rum-core");
const types_1 = require("../../../types");
const serializationUtils_1 = require("./serializationUtils");
const serializeStyleSheets_1 = require("./serializeStyleSheets");
const serializeAttributes_1 = require("./serializeAttributes");
function serializeNodeWithId(node, options) {
    const serializedNode = serializeNode(node, options);
    if (!serializedNode) {
        return null;
    }
    // Try to reuse the previous id
    const id = (0, serializationUtils_1.getSerializedNodeId)(node) || generateNextId();
    const serializedNodeWithId = serializedNode;
    serializedNodeWithId.id = id;
    (0, serializationUtils_1.setSerializedNodeId)(node, id);
    if (options.serializedNodeIds) {
        options.serializedNodeIds.add(id);
    }
    return serializedNodeWithId;
}
let _nextId = 1;
function generateNextId() {
    return _nextId++;
}
function serializeChildNodes(node, options) {
    const result = [];
    (0, browser_rum_core_1.forEachChildNodes)(node, (childNode) => {
        const serializedChildNode = serializeNodeWithId(childNode, options);
        if (serializedChildNode) {
            result.push(serializedChildNode);
        }
    });
    return result;
}
function serializeNode(node, options) {
    switch (node.nodeType) {
        case node.DOCUMENT_NODE:
            return serializeDocumentNode(node, options);
        case node.DOCUMENT_FRAGMENT_NODE:
            return serializeDocumentFragmentNode(node, options);
        case node.DOCUMENT_TYPE_NODE:
            return serializeDocumentTypeNode(node);
        case node.ELEMENT_NODE:
            return serializeElementNode(node, options);
        case node.TEXT_NODE:
            return serializeTextNode(node, options);
        case node.CDATA_SECTION_NODE:
            return serializeCDataNode();
    }
}
function serializeDocumentNode(document, options) {
    return {
        type: types_1.NodeType.Document,
        childNodes: serializeChildNodes(document, options),
        adoptedStyleSheets: (0, serializeStyleSheets_1.serializeStyleSheets)(document.adoptedStyleSheets),
    };
}
function serializeDocumentFragmentNode(element, options) {
    const isShadowRoot = (0, browser_rum_core_1.isNodeShadowRoot)(element);
    if (isShadowRoot) {
        options.serializationContext.shadowRootsController.addShadowRoot(element);
    }
    return {
        type: types_1.NodeType.DocumentFragment,
        childNodes: serializeChildNodes(element, options),
        isShadowRoot,
        adoptedStyleSheets: isShadowRoot ? (0, serializeStyleSheets_1.serializeStyleSheets)(element.adoptedStyleSheets) : undefined,
    };
}
function serializeDocumentTypeNode(documentType) {
    return {
        type: types_1.NodeType.DocumentType,
        name: documentType.name,
        publicId: documentType.publicId,
        systemId: documentType.systemId,
    };
}
/**
 * Serializing Element nodes involves capturing:
 * 1. HTML ATTRIBUTES:
 * 2. JS STATE:
 * - scroll offsets
 * - Form fields (input value, checkbox checked, option selection, range)
 * - Canvas state,
 * - Media (video/audio) play mode + currentTime
 * - iframe contents
 * - webcomponents
 * 3. CUSTOM PROPERTIES:
 * - height+width for when `hidden` to cover the element
 * 4. EXCLUDED INTERACTION STATE:
 * - focus (possible, but not worth perf impact)
 * - hover (tracked only via mouse activity)
 * - fullscreen mode
 */
function serializeElementNode(element, options) {
    const tagName = (0, serializationUtils_1.getValidTagName)(element.tagName);
    const isSVG = isSVGElement(element) || undefined;
    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the
    // parentNodePrivacyLevel option to avoid iterating over all parents
    const nodePrivacyLevel = (0, browser_rum_core_1.reducePrivacyLevel)((0, browser_rum_core_1.getNodeSelfPrivacyLevel)(element), options.parentNodePrivacyLevel);
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.HIDDEN) {
        const { width, height } = element.getBoundingClientRect();
        return {
            type: types_1.NodeType.Element,
            tagName,
            attributes: {
                rr_width: `${width}px`,
                rr_height: `${height}px`,
                [browser_rum_core_1.PRIVACY_ATTR_NAME]: browser_rum_core_1.PRIVACY_ATTR_VALUE_HIDDEN,
            },
            childNodes: [],
            isSVG,
        };
    }
    // Ignore Elements like Script and some Link, Metas
    if (nodePrivacyLevel === browser_rum_core_1.NodePrivacyLevel.IGNORE) {
        return;
    }
    const attributes = (0, serializeAttributes_1.serializeAttributes)(element, nodePrivacyLevel, options);
    let childNodes = [];
    if ((0, browser_rum_core_1.hasChildNodes)(element) &&
        // Do not serialize style children as the css rules are already in the _cssText attribute
        tagName !== 'style') {
        // OBJECT POOLING OPTIMIZATION:
        // We should not create a new object systematically as it could impact performances. Try to reuse
        // the same object as much as possible, and clone it only if we need to.
        let childNodesSerializationOptions;
        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {
            childNodesSerializationOptions = options;
        }
        else {
            childNodesSerializationOptions = {
                ...options,
                parentNodePrivacyLevel: nodePrivacyLevel,
                ignoreWhiteSpace: tagName === 'head',
            };
        }
        childNodes = serializeChildNodes(element, childNodesSerializationOptions);
    }
    return {
        type: types_1.NodeType.Element,
        tagName,
        attributes,
        childNodes,
        isSVG,
    };
}
function isSVGElement(el) {
    return el.tagName === 'svg' || el instanceof SVGElement;
}
/**
 * Text Nodes are dependant on Element nodes
 * Privacy levels are set on elements so we check the parentElement of a text node
 * for privacy level.
 */
function serializeTextNode(textNode, options) {
    const textContent = (0, browser_rum_core_1.getTextContent)(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);
    if (textContent === undefined) {
        return;
    }
    return {
        type: types_1.NodeType.Text,
        textContent,
    };
}
function serializeCDataNode() {
    return {
        type: types_1.NodeType.CDATA,
        textContent: '',
    };
}
//# sourceMappingURL=serializeNode.js.map