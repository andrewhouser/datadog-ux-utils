"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startRecording = startRecording;
const browser_core_1 = require("@datadog/browser-core");
const record_1 = require("../domain/record");
const segmentCollection_1 = require("../domain/segmentCollection");
const startRecordBridge_1 = require("../domain/startRecordBridge");
function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, telemetry, httpRequest) {
    const cleanupTasks = [];
    const reportError = (error) => {
        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });
        (0, browser_core_1.addTelemetryDebug)('Error reported to customer', { 'error.message': error.message });
    };
    const replayRequest = httpRequest || (0, browser_core_1.createHttpRequest)(configuration.sessionReplayEndpointBuilder, segmentCollection_1.SEGMENT_BYTES_LIMIT, reportError);
    let addRecord;
    if (!(0, browser_core_1.canUseEventBridge)()) {
        const segmentCollection = (0, segmentCollection_1.startSegmentCollection)(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);
        addRecord = segmentCollection.addRecord;
        cleanupTasks.push(segmentCollection.stop);
        const segmentTelemetry = (0, segmentCollection_1.startSegmentTelemetry)(configuration, telemetry, replayRequest.observable);
        cleanupTasks.push(segmentTelemetry.stop);
    }
    else {
        ;
        ({ addRecord } = (0, startRecordBridge_1.startRecordBridge)(viewHistory));
    }
    const { stop: stopRecording } = (0, record_1.record)({
        emit: addRecord,
        configuration,
        lifeCycle,
        viewHistory,
    });
    cleanupTasks.push(stopRecording);
    return {
        stop: () => {
            cleanupTasks.forEach((task) => task());
        },
    };
}
//# sourceMappingURL=startRecording.js.map