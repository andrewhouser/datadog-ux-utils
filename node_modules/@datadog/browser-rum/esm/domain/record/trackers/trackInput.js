import { instrumentSetter, addEventListeners, noop } from '@datadog/browser-core';
import { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';
import { IncrementalSource } from '../../../types';
import { getEventTarget } from '../eventsUtils';
import { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';
import { assembleIncrementalSnapshot } from '../assembly';
export function trackInput(configuration, inputCb, target = document) {
    const defaultPrivacyLevel = configuration.defaultPrivacyLevel;
    const lastInputStateMap = new WeakMap();
    const isShadowRoot = target !== document;
    const { stop: stopEventListeners } = addEventListeners(configuration, target, 
    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow
    // roots since it will be handled by the event listener that we did add to the document. Only
    // the 'change' event is blocked and needs to be handled on shadow roots.
    isShadowRoot ? ["change" /* DOM_EVENT.CHANGE */] : ["input" /* DOM_EVENT.INPUT */, "change" /* DOM_EVENT.CHANGE */], (event) => {
        const target = getEventTarget(event);
        if (target instanceof HTMLInputElement ||
            target instanceof HTMLTextAreaElement ||
            target instanceof HTMLSelectElement) {
            onElementChange(target);
        }
    }, {
        capture: true,
        passive: true,
    });
    let stopPropertySetterInstrumentation;
    if (!isShadowRoot) {
        const instrumentationStoppers = [
            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),
            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),
            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),
            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),
            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),
        ];
        stopPropertySetterInstrumentation = () => {
            instrumentationStoppers.forEach((stopper) => stopper.stop());
        };
    }
    else {
        stopPropertySetterInstrumentation = noop;
    }
    return {
        stop: () => {
            stopPropertySetterInstrumentation();
            stopEventListeners();
        },
    };
    function onElementChange(target) {
        const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);
        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
            return;
        }
        const type = target.type;
        let inputState;
        if (type === 'radio' || type === 'checkbox') {
            if (shouldMaskNode(target, nodePrivacyLevel)) {
                return;
            }
            inputState = { isChecked: target.checked };
        }
        else {
            const value = getElementInputValue(target, nodePrivacyLevel);
            if (value === undefined) {
                return;
            }
            inputState = { text: value };
        }
        // Can be multiple changes on the same node within the same batched mutation observation.
        cbWithDedup(target, inputState);
        // If a radio was checked, other radios with the same name attribute will be unchecked.
        const name = target.name;
        if (type === 'radio' && name && target.checked) {
            document.querySelectorAll(`input[type="radio"][name="${CSS.escape(name)}"]`).forEach((el) => {
                if (el !== target) {
                    // TODO: Consider the privacy implications for various differing input privacy levels
                    cbWithDedup(el, { isChecked: false });
                }
            });
        }
    }
    /**
     * There can be multiple changes on the same node within the same batched mutation observation.
     */
    function cbWithDedup(target, inputState) {
        if (!hasSerializedNode(target)) {
            return;
        }
        const lastInputState = lastInputStateMap.get(target);
        if (!lastInputState ||
            lastInputState.text !== inputState.text ||
            lastInputState.isChecked !== inputState.isChecked) {
            lastInputStateMap.set(target, inputState);
            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {
                id: getSerializedNodeId(target),
                ...inputState,
            }));
        }
    }
}
//# sourceMappingURL=trackInput.js.map