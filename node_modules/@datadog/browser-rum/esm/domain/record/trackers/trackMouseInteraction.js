import { addEventListeners } from '@datadog/browser-core';
import { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';
import { IncrementalSource, MouseInteractionType } from '../../../types';
import { assembleIncrementalSnapshot } from '../assembly';
import { getEventTarget } from '../eventsUtils';
import { getSerializedNodeId, hasSerializedNode } from '../serialization';
import { tryToComputeCoordinates } from './trackMove';
const eventTypeToMouseInteraction = {
    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This
    // allows to reference such records from Frustration records.
    //
    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records
    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace
    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to
    // convey such interaction. This would cleanly solve the issue since we would have
    // `PointerInteraction/Up` records that we could reference from `Frustration` records.
    ["pointerup" /* DOM_EVENT.POINTER_UP */]: MouseInteractionType.MouseUp,
    ["mousedown" /* DOM_EVENT.MOUSE_DOWN */]: MouseInteractionType.MouseDown,
    ["click" /* DOM_EVENT.CLICK */]: MouseInteractionType.Click,
    ["contextmenu" /* DOM_EVENT.CONTEXT_MENU */]: MouseInteractionType.ContextMenu,
    ["dblclick" /* DOM_EVENT.DBL_CLICK */]: MouseInteractionType.DblClick,
    ["focus" /* DOM_EVENT.FOCUS */]: MouseInteractionType.Focus,
    ["blur" /* DOM_EVENT.BLUR */]: MouseInteractionType.Blur,
    ["touchstart" /* DOM_EVENT.TOUCH_START */]: MouseInteractionType.TouchStart,
    ["touchend" /* DOM_EVENT.TOUCH_END */]: MouseInteractionType.TouchEnd,
};
export function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {
    const handler = (event) => {
        const target = getEventTarget(event);
        if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||
            !hasSerializedNode(target)) {
            return;
        }
        const id = getSerializedNodeId(target);
        const type = eventTypeToMouseInteraction[event.type];
        let interaction;
        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {
            const coordinates = tryToComputeCoordinates(event);
            if (!coordinates) {
                return;
            }
            interaction = { id, type, x: coordinates.x, y: coordinates.y };
        }
        else {
            interaction = { id, type };
        }
        const record = {
            id: recordIds.getIdForEvent(event),
            ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction),
        };
        mouseInteractionCb(record);
    };
    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {
        capture: true,
        passive: true,
    });
}
//# sourceMappingURL=trackMouseInteraction.js.map