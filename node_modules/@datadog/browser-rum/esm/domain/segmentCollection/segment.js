import { RecordType } from '../../types';
import * as replayStats from '../replayStats';
import { aggregateSerializationStats, createSerializationStats } from '../record';
export function createSegment({ context, creationReason, encoder, }) {
    let encodedBytesCount = 0;
    const viewId = context.view.id;
    const indexInView = replayStats.getSegmentsCount(viewId);
    const metadata = {
        start: Infinity,
        end: -Infinity,
        creation_reason: creationReason,
        records_count: 0,
        has_full_snapshot: false,
        index_in_view: indexInView,
        source: 'browser',
        ...context,
    };
    const serializationStats = createSerializationStats();
    replayStats.addSegment(viewId);
    function addRecord(record, stats, callback) {
        metadata.start = Math.min(metadata.start, record.timestamp);
        metadata.end = Math.max(metadata.end, record.timestamp);
        metadata.records_count += 1;
        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);
        if (stats) {
            aggregateSerializationStats(serializationStats, stats);
        }
        const prefix = encoder.isEmpty ? '{"records":[' : ',';
        encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {
            encodedBytesCount += additionalEncodedBytesCount;
            callback(encodedBytesCount);
        });
    }
    function flush(callback) {
        if (encoder.isEmpty) {
            throw new Error('Empty segment flushed');
        }
        encoder.write(`],${JSON.stringify(metadata).slice(1)}\n`);
        encoder.finish((encoderResult) => {
            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);
            callback(metadata, serializationStats, encoderResult);
        });
    }
    return { addRecord, flush };
}
//# sourceMappingURL=segment.js.map