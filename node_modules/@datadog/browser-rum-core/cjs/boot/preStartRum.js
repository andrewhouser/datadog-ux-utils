"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPreStartStrategy = createPreStartStrategy;
const browser_core_1 = require("@datadog/browser-core");
const configuration_1 = require("../domain/configuration");
const vitalCollection_1 = require("../domain/vital/vitalCollection");
const plugins_1 = require("../domain/plugins");
function createPreStartStrategy({ ignoreInitIfSyntheticsWillInjectRum = true, startDeflateWorker }, trackingConsentState, customVitalsState, doStartRum) {
    const bufferApiCalls = (0, browser_core_1.createBoundedBuffer)();
    // TODO next major: remove the globalContextManager, userContextManager and accountContextManager from preStartStrategy and use an empty context instead
    const globalContext = (0, browser_core_1.buildGlobalContextManager)();
    bufferContextCalls(globalContext, browser_core_1.CustomerContextKey.globalContext, bufferApiCalls);
    const userContext = (0, browser_core_1.buildUserContextManager)();
    bufferContextCalls(userContext, browser_core_1.CustomerContextKey.userContext, bufferApiCalls);
    const accountContext = (0, browser_core_1.buildAccountContextManager)();
    bufferContextCalls(accountContext, browser_core_1.CustomerContextKey.accountContext, bufferApiCalls);
    let firstStartViewCall;
    let deflateWorker;
    let cachedInitConfiguration;
    let cachedConfiguration;
    const trackingConsentStateSubscription = trackingConsentState.observable.subscribe(tryStartRum);
    const emptyContext = {};
    function tryStartRum() {
        if (!cachedInitConfiguration || !cachedConfiguration || !trackingConsentState.isGranted()) {
            return;
        }
        trackingConsentStateSubscription.unsubscribe();
        let initialViewOptions;
        if (cachedConfiguration.trackViewsManually) {
            if (!firstStartViewCall) {
                return;
            }
            // An initial view is always created when starting RUM.
            // When tracking views automatically, any startView call before RUM start creates an extra
            // view.
            // When tracking views manually, we use the ViewOptions from the first startView call as the
            // initial view options, and we remove the actual startView call so we don't create an extra
            // view.
            bufferApiCalls.remove(firstStartViewCall.callback);
            initialViewOptions = firstStartViewCall.options;
        }
        const startRumResult = doStartRum(cachedConfiguration, deflateWorker, initialViewOptions);
        bufferApiCalls.drain(startRumResult);
    }
    function doInit(initConfiguration) {
        const eventBridgeAvailable = (0, browser_core_1.canUseEventBridge)();
        if (eventBridgeAvailable) {
            initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
        }
        // Update the exposed initConfiguration to reflect the bridge and remote configuration overrides
        cachedInitConfiguration = initConfiguration;
        (0, browser_core_1.addTelemetryConfiguration)((0, configuration_1.serializeRumConfiguration)(initConfiguration));
        if (cachedConfiguration) {
            (0, browser_core_1.displayAlreadyInitializedError)('DD_RUM', initConfiguration);
            return;
        }
        const configuration = (0, configuration_1.validateAndBuildRumConfiguration)(initConfiguration);
        if (!configuration) {
            return;
        }
        if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {
            browser_core_1.display.warn('No storage available for session. We will not send any data.');
            return;
        }
        if (configuration.compressIntakeRequests && !eventBridgeAvailable && startDeflateWorker) {
            deflateWorker = startDeflateWorker(configuration, 'Datadog RUM', 
            // Worker initialization can fail asynchronously, especially in Firefox where even CSP
            // issues are reported asynchronously. For now, the SDK will continue its execution even if
            // data won't be sent to Datadog. We could improve this behavior in the future.
            browser_core_1.noop);
            if (!deflateWorker) {
                // `startDeflateWorker` should have logged an error message explaining the issue
                return;
            }
        }
        cachedConfiguration = configuration;
        // Instrument fetch to track network requests
        // This is needed in case the consent is not granted and some customer
        // library (Apollo Client) is storing uninstrumented fetch to be used later
        // The subscription is needed so that the instrumentation process is completed
        (0, browser_core_1.initFetchObservable)().subscribe(browser_core_1.noop);
        trackingConsentState.tryToInit(configuration.trackingConsent);
        tryStartRum();
    }
    const addDurationVital = (vital) => {
        bufferApiCalls.add((startRumResult) => startRumResult.addDurationVital(vital));
    };
    const strategy = {
        init(initConfiguration, publicApi) {
            if (!initConfiguration) {
                browser_core_1.display.error('Missing configuration');
                return;
            }
            // Set the experimental feature flags as early as possible, so we can use them in most places
            (0, browser_core_1.initFeatureFlags)(initConfiguration.enableExperimentalFeatures);
            // Expose the initial configuration regardless of initialization success.
            cachedInitConfiguration = initConfiguration;
            // If we are in a Synthetics test configured to automatically inject a RUM instance, we want
            // to completely discard the customer application RUM instance by ignoring their init() call.
            // But, we should not ignore the init() call from the Synthetics-injected RUM instance, so the
            // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.
            if (ignoreInitIfSyntheticsWillInjectRum && (0, browser_core_1.willSyntheticsInjectRum)()) {
                return;
            }
            (0, plugins_1.callPluginsMethod)(initConfiguration.plugins, 'onInit', { initConfiguration, publicApi });
            if (initConfiguration.remoteConfigurationId) {
                (0, configuration_1.fetchAndApplyRemoteConfiguration)(initConfiguration)
                    .then((initConfiguration) => {
                    if (initConfiguration) {
                        doInit(initConfiguration);
                    }
                })
                    .catch(browser_core_1.monitorError);
            }
            else {
                doInit(initConfiguration);
            }
        },
        get initConfiguration() {
            return cachedInitConfiguration;
        },
        getInternalContext: browser_core_1.noop,
        stopSession: browser_core_1.noop,
        addTiming(name, time = (0, browser_core_1.timeStampNow)()) {
            bufferApiCalls.add((startRumResult) => startRumResult.addTiming(name, time));
        },
        startView(options, startClocks = (0, browser_core_1.clocksNow)()) {
            const callback = (startRumResult) => {
                startRumResult.startView(options, startClocks);
            };
            bufferApiCalls.add(callback);
            if (!firstStartViewCall) {
                firstStartViewCall = { options, callback };
                tryStartRum();
            }
        },
        setViewName(name) {
            bufferApiCalls.add((startRumResult) => startRumResult.setViewName(name));
        },
        // View context APIs
        setViewContext(context) {
            bufferApiCalls.add((startRumResult) => startRumResult.setViewContext(context));
        },
        setViewContextProperty(key, value) {
            bufferApiCalls.add((startRumResult) => startRumResult.setViewContextProperty(key, value));
        },
        getViewContext: () => emptyContext,
        globalContext,
        userContext,
        accountContext,
        addAction(action) {
            bufferApiCalls.add((startRumResult) => startRumResult.addAction(action));
        },
        addError(providedError) {
            bufferApiCalls.add((startRumResult) => startRumResult.addError(providedError));
        },
        addFeatureFlagEvaluation(key, value) {
            bufferApiCalls.add((startRumResult) => startRumResult.addFeatureFlagEvaluation(key, value));
        },
        startDurationVital(name, options) {
            return (0, vitalCollection_1.startDurationVital)(customVitalsState, name, options);
        },
        stopDurationVital(name, options) {
            (0, vitalCollection_1.stopDurationVital)(addDurationVital, customVitalsState, name, options);
        },
        addDurationVital,
    };
    return strategy;
}
function overrideInitConfigurationForBridge(initConfiguration) {
    var _a, _b;
    return {
        ...initConfiguration,
        applicationId: '00000000-aaaa-0000-aaaa-000000000000',
        clientToken: 'empty',
        sessionSampleRate: 100,
        defaultPrivacyLevel: (_a = initConfiguration.defaultPrivacyLevel) !== null && _a !== void 0 ? _a : (_b = (0, browser_core_1.getEventBridge)()) === null || _b === void 0 ? void 0 : _b.getPrivacyLevel(),
    };
}
function bufferContextCalls(preStartContextManager, name, bufferApiCalls) {
    preStartContextManager.changeObservable.subscribe(() => {
        const context = preStartContextManager.getContext();
        bufferApiCalls.add((startRumResult) => startRumResult[name].setContext(context));
    });
}
//# sourceMappingURL=preStartRum.js.map