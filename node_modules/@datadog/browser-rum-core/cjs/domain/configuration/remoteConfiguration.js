"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAndApplyRemoteConfiguration = fetchAndApplyRemoteConfiguration;
exports.applyRemoteConfiguration = applyRemoteConfiguration;
exports.fetchRemoteConfiguration = fetchRemoteConfiguration;
exports.buildEndpoint = buildEndpoint;
const browser_core_1 = require("@datadog/browser-core");
const REMOTE_CONFIGURATION_VERSION = 'v1';
const SUPPORTED_FIELDS = [
    'applicationId',
    'service',
    'env',
    'version',
    'sessionSampleRate',
    'sessionReplaySampleRate',
    'defaultPrivacyLevel',
    'enablePrivacyForActionName',
    'traceSampleRate',
    'trackSessionAcrossSubdomains',
    'allowedTracingUrls',
    'allowedTrackingOrigins',
];
async function fetchAndApplyRemoteConfiguration(initConfiguration) {
    const fetchResult = await fetchRemoteConfiguration(initConfiguration);
    if (!fetchResult.ok) {
        browser_core_1.display.error(fetchResult.error);
        return;
    }
    return applyRemoteConfiguration(initConfiguration, fetchResult.value);
}
function applyRemoteConfiguration(initConfiguration, rumRemoteConfiguration) {
    // intents:
    // - explicitly set each supported field to limit risk in case an attacker can create configurations
    // - check the existence in the remote config to avoid clearing a provided init field
    const appliedConfiguration = { ...initConfiguration };
    SUPPORTED_FIELDS.forEach((option) => {
        if (option in rumRemoteConfiguration) {
            appliedConfiguration[option] = resolveConfigurationProperty(rumRemoteConfiguration[option]);
        }
    });
    return appliedConfiguration;
}
function resolveConfigurationProperty(property) {
    if (Array.isArray(property)) {
        return property.map(resolveConfigurationProperty);
    }
    if (isObject(property)) {
        if (isSerializedOption(property)) {
            const type = property.rcSerializedType;
            switch (type) {
                case 'string':
                    return property.value;
                case 'regex':
                    return resolveRegex(property.value);
                default:
                    browser_core_1.display.error(`Unsupported remote configuration: "rcSerializedType": "${type}"`);
                    return;
            }
        }
        return (0, browser_core_1.mapValues)(property, resolveConfigurationProperty);
    }
    return property;
}
function isObject(property) {
    return typeof property === 'object' && property !== null;
}
function isSerializedOption(value) {
    return 'rcSerializedType' in value;
}
function resolveRegex(pattern) {
    try {
        return new RegExp(pattern);
    }
    catch (_a) {
        browser_core_1.display.error(`Invalid regex in the remote configuration: '${pattern}'`);
    }
}
async function fetchRemoteConfiguration(configuration) {
    let response;
    try {
        response = await fetch(buildEndpoint(configuration));
    }
    catch (_a) {
        response = undefined;
    }
    if (!response || !response.ok) {
        return {
            ok: false,
            error: new Error('Error fetching the remote configuration.'),
        };
    }
    const remoteConfiguration = await response.json();
    if (remoteConfiguration.rum) {
        return {
            ok: true,
            value: remoteConfiguration.rum,
        };
    }
    return {
        ok: false,
        error: new Error('No remote configuration for RUM.'),
    };
}
function buildEndpoint(configuration) {
    if (configuration.remoteConfigurationProxy) {
        return configuration.remoteConfigurationProxy;
    }
    return `https://sdk-configuration.${(0, browser_core_1.buildEndpointHost)('rum', configuration)}/${REMOTE_CONFIGURATION_VERSION}/${encodeURIComponent(configuration.remoteConfigurationId)}.json`;
}
//# sourceMappingURL=remoteConfiguration.js.map