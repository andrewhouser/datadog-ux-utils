"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.limitModification = limitModification;
const browser_core_1 = require("@datadog/browser-core");
/**
 * Allows declaring and enforcing modifications to specific fields of an object.
 * Only supports modifying properties of an object (even if nested in an array).
 * Does not support array manipulation (adding/removing items).
 */
function limitModification(object, modifiableFieldPaths, modifier) {
    const clone = (0, browser_core_1.deepClone)(object);
    const result = modifier(clone);
    (0, browser_core_1.objectEntries)(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => 
    // Traverse both object and clone simultaneously up to the path and apply the modification from the clone to the original object when the type is valid
    setValueAtPath(object, clone, fieldPath.split(/\.|(?=\[\])/), fieldType));
    return result;
}
function setValueAtPath(object, clone, pathSegments, fieldType) {
    const [field, ...restPathSegments] = pathSegments;
    if (field === '[]') {
        if (Array.isArray(object) && Array.isArray(clone)) {
            object.forEach((item, i) => setValueAtPath(item, clone[i], restPathSegments, fieldType));
        }
        return;
    }
    if (!isValidObject(object) || !isValidObject(clone)) {
        return;
    }
    if (restPathSegments.length > 0) {
        return setValueAtPath(object[field], clone[field], restPathSegments, fieldType);
    }
    setNestedValue(object, field, clone[field], fieldType);
}
function setNestedValue(object, field, value, fieldType) {
    const newType = (0, browser_core_1.getType)(value);
    if (newType === fieldType) {
        object[field] = (0, browser_core_1.sanitize)(value);
    }
    else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {
        object[field] = {};
    }
}
function isValidObject(object) {
    return (0, browser_core_1.getType)(object) === 'object';
}
//# sourceMappingURL=limitModification.js.map