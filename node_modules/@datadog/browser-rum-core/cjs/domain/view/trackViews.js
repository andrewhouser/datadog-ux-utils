"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KEEP_TRACKING_AFTER_VIEW_DELAY = exports.SESSION_KEEP_ALIVE_INTERVAL = exports.THROTTLE_VIEW_UPDATE_PERIOD = void 0;
exports.trackViews = trackViews;
const browser_core_1 = require("@datadog/browser-core");
const rawRumEvent_types_1 = require("../../rawRumEvent.types");
const trackViewEventCounts_1 = require("./trackViewEventCounts");
const trackInitialViewMetrics_1 = require("./viewMetrics/trackInitialViewMetrics");
const trackCommonViewMetrics_1 = require("./viewMetrics/trackCommonViewMetrics");
const bfCacheSupport_1 = require("./bfCacheSupport");
const trackBfcacheMetrics_1 = require("./viewMetrics/trackBfcacheMetrics");
exports.THROTTLE_VIEW_UPDATE_PERIOD = 3000;
exports.SESSION_KEEP_ALIVE_INTERVAL = 5 * browser_core_1.ONE_MINUTE;
// Some events or metrics can be captured after the end of the view. To avoid missing those;
// an arbitrary delay is added for stopping their tracking after the view ends.
//
// Ideally, we would not stop and keep tracking events or metrics until the end of the session.
// But this might have a small performance impact if there are many many views.
// So let's have a fairly short delay improving the situation in most cases and avoid impacting performances too much.
exports.KEEP_TRACKING_AFTER_VIEW_DELAY = 5 * browser_core_1.ONE_MINUTE;
function trackViews(location, lifeCycle, domMutationObservable, windowOpenObservable, configuration, locationChangeObservable, areViewsTrackedAutomatically, initialViewOptions) {
    const activeViews = new Set();
    let currentView = startNewView(rawRumEvent_types_1.ViewLoadingType.INITIAL_LOAD, (0, browser_core_1.clocksOrigin)(), initialViewOptions);
    let stopOnBFCacheRestore;
    startViewLifeCycle();
    let locationChangeSubscription;
    if (areViewsTrackedAutomatically) {
        locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable);
        if (configuration.trackBfcacheViews) {
            stopOnBFCacheRestore = (0, bfCacheSupport_1.onBFCacheRestore)(configuration, (pageshowEvent) => {
                currentView.end();
                const startClocks = (0, browser_core_1.relativeToClocks)(pageshowEvent.timeStamp);
                currentView = startNewView(rawRumEvent_types_1.ViewLoadingType.BF_CACHE, startClocks, undefined);
            });
        }
    }
    function startNewView(loadingType, startClocks, viewOptions) {
        const newlyCreatedView = newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, location, loadingType, startClocks, viewOptions);
        activeViews.add(newlyCreatedView);
        newlyCreatedView.stopObservable.subscribe(() => {
            activeViews.delete(newlyCreatedView);
        });
        return newlyCreatedView;
    }
    function startViewLifeCycle() {
        lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {
            // Renew view on session renewal
            currentView = startNewView(rawRumEvent_types_1.ViewLoadingType.ROUTE_CHANGE, undefined, {
                name: currentView.name,
                service: currentView.service,
                version: currentView.version,
                context: currentView.contextManager.getContext(),
            });
        });
        lifeCycle.subscribe(9 /* LifeCycleEventType.SESSION_EXPIRED */, () => {
            currentView.end({ sessionIsActive: false });
        });
    }
    function renewViewOnLocationChange(locationChangeObservable) {
        return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {
            if (areDifferentLocation(oldLocation, newLocation)) {
                currentView.end();
                currentView = startNewView(rawRumEvent_types_1.ViewLoadingType.ROUTE_CHANGE);
            }
        });
    }
    return {
        addTiming: (name, time = (0, browser_core_1.timeStampNow)()) => {
            currentView.addTiming(name, time);
        },
        startView: (options, startClocks) => {
            currentView.end({ endClocks: startClocks });
            currentView = startNewView(rawRumEvent_types_1.ViewLoadingType.ROUTE_CHANGE, startClocks, options);
        },
        setViewContext: (context) => {
            currentView.contextManager.setContext(context);
        },
        setViewContextProperty: (key, value) => {
            currentView.contextManager.setContextProperty(key, value);
        },
        setViewName: (name) => {
            currentView.setViewName(name);
        },
        getViewContext: () => currentView.contextManager.getContext(),
        stop: () => {
            if (locationChangeSubscription) {
                locationChangeSubscription.unsubscribe();
            }
            if (stopOnBFCacheRestore) {
                stopOnBFCacheRestore();
            }
            currentView.end();
            activeViews.forEach((view) => view.stop());
        },
    };
}
function newView(lifeCycle, domMutationObservable, windowOpenObservable, configuration, initialLocation, loadingType, startClocks = (0, browser_core_1.clocksNow)(), viewOptions) {
    // Setup initial values
    const id = (0, browser_core_1.generateUUID)();
    const stopObservable = new browser_core_1.Observable();
    const customTimings = {};
    let documentVersion = 0;
    let endClocks;
    const location = (0, browser_core_1.shallowClone)(initialLocation);
    const contextManager = (0, browser_core_1.createContextManager)();
    let sessionIsActive = true;
    let name = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.name;
    const service = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.service) || configuration.service;
    const version = (viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.version) || configuration.version;
    const context = viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.context;
    if (context) {
        contextManager.setContext(context);
    }
    const viewCreatedEvent = {
        id,
        name,
        startClocks,
        service,
        version,
        context,
    };
    lifeCycle.notify(1 /* LifeCycleEventType.BEFORE_VIEW_CREATED */, viewCreatedEvent);
    lifeCycle.notify(2 /* LifeCycleEventType.VIEW_CREATED */, viewCreatedEvent);
    // Update the view every time the measures are changing
    const { throttled, cancel: cancelScheduleViewUpdate } = (0, browser_core_1.throttle)(triggerViewUpdate, exports.THROTTLE_VIEW_UPDATE_PERIOD, {
        leading: false,
    });
    const { setLoadEvent, setViewEnd, stop: stopCommonViewMetricsTracking, stopINPTracking, getCommonViewMetrics, } = (0, trackCommonViewMetrics_1.trackCommonViewMetrics)(lifeCycle, domMutationObservable, windowOpenObservable, configuration, scheduleViewUpdate, loadingType, startClocks);
    const { stop: stopInitialViewMetricsTracking, initialViewMetrics } = loadingType === rawRumEvent_types_1.ViewLoadingType.INITIAL_LOAD
        ? (0, trackInitialViewMetrics_1.trackInitialViewMetrics)(configuration, startClocks, setLoadEvent, scheduleViewUpdate)
        : { stop: browser_core_1.noop, initialViewMetrics: {} };
    // Start BFCache-specific metrics when restoring from BFCache
    if (loadingType === rawRumEvent_types_1.ViewLoadingType.BF_CACHE) {
        (0, trackBfcacheMetrics_1.trackBfcacheMetrics)(startClocks, initialViewMetrics, scheduleViewUpdate);
    }
    const { stop: stopEventCountsTracking, eventCounts } = (0, trackViewEventCounts_1.trackViewEventCounts)(lifeCycle, id, scheduleViewUpdate);
    // Session keep alive
    const keepAliveIntervalId = (0, browser_core_1.setInterval)(triggerViewUpdate, exports.SESSION_KEEP_ALIVE_INTERVAL);
    const pageMayExitSubscription = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, (pageMayExitEvent) => {
        if (pageMayExitEvent.reason === browser_core_1.PageExitReason.UNLOADING) {
            triggerViewUpdate();
        }
    });
    // Initial view update
    triggerViewUpdate();
    // View context update should always be throttled
    contextManager.changeObservable.subscribe(scheduleViewUpdate);
    function triggerBeforeViewUpdate() {
        lifeCycle.notify(3 /* LifeCycleEventType.BEFORE_VIEW_UPDATED */, {
            id,
            name,
            context: contextManager.getContext(),
            startClocks,
            sessionIsActive,
        });
    }
    function scheduleViewUpdate() {
        triggerBeforeViewUpdate();
        throttled();
    }
    function triggerViewUpdate() {
        cancelScheduleViewUpdate();
        triggerBeforeViewUpdate();
        documentVersion += 1;
        const currentEnd = endClocks === undefined ? (0, browser_core_1.timeStampNow)() : endClocks.timeStamp;
        lifeCycle.notify(4 /* LifeCycleEventType.VIEW_UPDATED */, {
            customTimings,
            documentVersion,
            id,
            name,
            service,
            version,
            context: contextManager.getContext(),
            loadingType,
            location,
            startClocks,
            commonViewMetrics: getCommonViewMetrics(),
            initialViewMetrics,
            duration: (0, browser_core_1.elapsed)(startClocks.timeStamp, currentEnd),
            isActive: endClocks === undefined,
            sessionIsActive,
            eventCounts,
        });
    }
    return {
        get name() {
            return name;
        },
        service,
        version,
        contextManager,
        stopObservable,
        end(options = {}) {
            var _a, _b;
            if (endClocks) {
                // view already ended
                return;
            }
            endClocks = (_a = options.endClocks) !== null && _a !== void 0 ? _a : (0, browser_core_1.clocksNow)();
            sessionIsActive = (_b = options.sessionIsActive) !== null && _b !== void 0 ? _b : true;
            lifeCycle.notify(5 /* LifeCycleEventType.VIEW_ENDED */, { endClocks });
            lifeCycle.notify(6 /* LifeCycleEventType.AFTER_VIEW_ENDED */, { endClocks });
            (0, browser_core_1.clearInterval)(keepAliveIntervalId);
            setViewEnd(endClocks.relative);
            stopCommonViewMetricsTracking();
            pageMayExitSubscription.unsubscribe();
            triggerViewUpdate();
            (0, browser_core_1.setTimeout)(() => {
                this.stop();
            }, exports.KEEP_TRACKING_AFTER_VIEW_DELAY);
        },
        stop() {
            stopInitialViewMetricsTracking();
            stopEventCountsTracking();
            stopINPTracking();
            stopObservable.notify();
        },
        addTiming(name, time) {
            if (endClocks) {
                return;
            }
            const relativeTime = (0, browser_core_1.looksLikeRelativeTime)(time) ? time : (0, browser_core_1.elapsed)(startClocks.timeStamp, time);
            customTimings[sanitizeTiming(name)] = relativeTime;
            scheduleViewUpdate();
        },
        setViewName(updatedName) {
            name = updatedName;
            triggerViewUpdate();
        },
    };
}
/**
 * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $
 */
function sanitizeTiming(name) {
    const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');
    if (sanitized !== name) {
        browser_core_1.display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`);
    }
    return sanitized;
}
function areDifferentLocation(currentLocation, otherLocation) {
    return (currentLocation.pathname !== otherLocation.pathname ||
        (!isHashAnAnchor(otherLocation.hash) &&
            getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash)));
}
function isHashAnAnchor(hash) {
    const correspondingId = hash.substring(1);
    // check if the correspondingId is empty because on Firefox an empty string passed to getElementById() prints a consol warning
    return correspondingId !== '' && !!document.getElementById(correspondingId);
}
function getPathFromHash(hash) {
    const index = hash.indexOf('?');
    return index < 0 ? hash : hash.slice(0, index);
}
//# sourceMappingURL=trackViews.js.map