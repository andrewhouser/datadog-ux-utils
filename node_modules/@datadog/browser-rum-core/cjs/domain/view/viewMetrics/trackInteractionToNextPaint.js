"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_INP_VALUE = void 0;
exports.trackInteractionToNextPaint = trackInteractionToNextPaint;
exports.trackViewInteractionCount = trackViewInteractionCount;
exports.isInteractionToNextPaintSupported = isInteractionToNextPaintSupported;
const browser_core_1 = require("@datadog/browser-core");
const performanceObservable_1 = require("../../../browser/performanceObservable");
const rawRumEvent_types_1 = require("../../../rawRumEvent.types");
const getSelectorFromElement_1 = require("../../getSelectorFromElement");
const htmlDomUtils_1 = require("../../../browser/htmlDomUtils");
const interactionSelectorCache_1 = require("../../action/interactionSelectorCache");
const interactionCountPolyfill_1 = require("./interactionCountPolyfill");
// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.
const MAX_INTERACTION_ENTRIES = 10;
// Arbitrary value to cap INP outliers
exports.MAX_INP_VALUE = (1 * browser_core_1.ONE_MINUTE);
/**
 * Track the interaction to next paint (INP).
 * To avoid outliers, return the p98 worst interaction of the view.
 * Documentation: https://web.dev/inp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts
 */
function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType) {
    if (!isInteractionToNextPaintSupported()) {
        return {
            getInteractionToNextPaint: () => undefined,
            setViewEnd: browser_core_1.noop,
            stop: browser_core_1.noop,
        };
    }
    const { getViewInteractionCount, stopViewInteractionCount } = trackViewInteractionCount(viewLoadingType);
    let viewEnd = Infinity;
    const longestInteractions = trackLongestInteractions(getViewInteractionCount);
    let interactionToNextPaint = -1;
    let interactionToNextPaintTargetSelector;
    let interactionToNextPaintStartTime;
    function handleEntries(entries) {
        for (const entry of entries) {
            if (entry.interactionId &&
                // Check the entry start time is inside the view bounds because some view interactions can be reported after the view end (if long duration).
                entry.startTime >= viewStart &&
                entry.startTime <= viewEnd) {
                longestInteractions.process(entry);
            }
        }
        const newInteraction = longestInteractions.estimateP98Interaction();
        if (newInteraction && newInteraction.duration !== interactionToNextPaint) {
            interactionToNextPaint = newInteraction.duration;
            interactionToNextPaintStartTime = (0, browser_core_1.elapsed)(viewStart, newInteraction.startTime);
            interactionToNextPaintTargetSelector = (0, interactionSelectorCache_1.getInteractionSelector)(newInteraction.startTime);
            if (!interactionToNextPaintTargetSelector && newInteraction.target && (0, htmlDomUtils_1.isElementNode)(newInteraction.target)) {
                interactionToNextPaintTargetSelector = (0, getSelectorFromElement_1.getSelectorFromElement)(newInteraction.target, configuration.actionNameAttribute);
            }
        }
    }
    const firstInputSubscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: performanceObservable_1.RumPerformanceEntryType.FIRST_INPUT,
        buffered: true,
    }).subscribe(handleEntries);
    const eventSubscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: performanceObservable_1.RumPerformanceEntryType.EVENT,
        // durationThreshold only impact PerformanceEventTiming entries used for INP computation which requires a threshold at 40 (default is 104ms)
        // cf: https://github.com/GoogleChrome/web-vitals/blob/3806160ffbc93c3c4abf210a167b81228172b31c/src/onINP.ts#L202-L210
        durationThreshold: 40,
        buffered: true,
    }).subscribe(handleEntries);
    return {
        getInteractionToNextPaint: () => {
            // If no INP duration where captured because of the performanceObserver 40ms threshold
            // but the view interaction count > 0 then report 0
            if (interactionToNextPaint >= 0) {
                return {
                    value: Math.min(interactionToNextPaint, exports.MAX_INP_VALUE),
                    targetSelector: interactionToNextPaintTargetSelector,
                    time: interactionToNextPaintStartTime,
                };
            }
            else if (getViewInteractionCount()) {
                return {
                    value: 0,
                };
            }
        },
        setViewEnd: (viewEndTime) => {
            viewEnd = viewEndTime;
            stopViewInteractionCount();
        },
        stop: () => {
            eventSubscription.unsubscribe();
            firstInputSubscription.unsubscribe();
        },
    };
}
function trackLongestInteractions(getViewInteractionCount) {
    const longestInteractions = [];
    function sortAndTrimLongestInteractions() {
        longestInteractions.sort((a, b) => b.duration - a.duration).splice(MAX_INTERACTION_ENTRIES);
    }
    return {
        /**
         * Process the performance entry:
         * - if its duration is long enough, add the performance entry to the list of worst interactions
         * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions
         */
        process(entry) {
            const interactionIndex = longestInteractions.findIndex((interaction) => entry.interactionId === interaction.interactionId);
            const minLongestInteraction = longestInteractions[longestInteractions.length - 1];
            if (interactionIndex !== -1) {
                if (entry.duration > longestInteractions[interactionIndex].duration) {
                    longestInteractions[interactionIndex] = entry;
                    sortAndTrimLongestInteractions();
                }
            }
            else if (longestInteractions.length < MAX_INTERACTION_ENTRIES ||
                entry.duration > minLongestInteraction.duration) {
                longestInteractions.push(entry);
                sortAndTrimLongestInteractions();
            }
        },
        /**
         * Compute the p98 longest interaction.
         * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.
         */
        estimateP98Interaction() {
            const interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));
            return longestInteractions[interactionIndex];
        },
    };
}
function trackViewInteractionCount(viewLoadingType) {
    (0, interactionCountPolyfill_1.initInteractionCountPolyfill)();
    const previousInteractionCount = viewLoadingType === rawRumEvent_types_1.ViewLoadingType.INITIAL_LOAD ? 0 : (0, interactionCountPolyfill_1.getInteractionCount)();
    let state = { stopped: false };
    function computeViewInteractionCount() {
        return (0, interactionCountPolyfill_1.getInteractionCount)() - previousInteractionCount;
    }
    return {
        getViewInteractionCount: () => {
            if (state.stopped) {
                return state.interactionCount;
            }
            return computeViewInteractionCount();
        },
        stopViewInteractionCount: () => {
            state = { stopped: true, interactionCount: computeViewInteractionCount() };
        },
    };
}
function isInteractionToNextPaintSupported() {
    return ((0, performanceObservable_1.supportPerformanceTimingEvent)(performanceObservable_1.RumPerformanceEntryType.EVENT) &&
        window.PerformanceEventTiming &&
        'interactionId' in PerformanceEventTiming.prototype);
}
//# sourceMappingURL=trackInteractionToNextPaint.js.map