"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackNavigationTimings = trackNavigationTimings;
const browser_core_1 = require("@datadog/browser-core");
const performanceUtils_1 = require("../../../browser/performanceUtils");
function trackNavigationTimings(configuration, callback, getNavigationEntryImpl = performanceUtils_1.getNavigationEntry) {
    return waitAfterLoadEvent(configuration, () => {
        const entry = getNavigationEntryImpl();
        if (!isIncompleteNavigation(entry)) {
            callback(processNavigationEntry(entry));
        }
    });
}
function processNavigationEntry(entry) {
    return {
        domComplete: entry.domComplete,
        domContentLoaded: entry.domContentLoadedEventEnd,
        domInteractive: entry.domInteractive,
        loadEvent: entry.loadEventEnd,
        // In some cases the value reported is negative or is larger
        // than the current page time. Ignore these cases:
        // https://github.com/GoogleChrome/web-vitals/issues/137
        // https://github.com/GoogleChrome/web-vitals/issues/162
        firstByte: entry.responseStart >= 0 && entry.responseStart <= (0, browser_core_1.relativeNow)() ? entry.responseStart : undefined,
    };
}
function isIncompleteNavigation(entry) {
    return entry.loadEventEnd <= 0;
}
function waitAfterLoadEvent(configuration, callback) {
    let timeoutId;
    const { stop: stopOnReadyState } = (0, browser_core_1.runOnReadyState)(configuration, 'complete', () => {
        // Invoke the callback a bit after the actual load event, so the "loadEventEnd" timing is accurate
        timeoutId = (0, browser_core_1.setTimeout)(() => callback());
    });
    return {
        stop: () => {
            stopOnReadyState();
            (0, browser_core_1.clearTimeout)(timeoutId);
        },
    };
}
//# sourceMappingURL=trackNavigationTimings.js.map