"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackLoadingTime = trackLoadingTime;
const browser_core_1 = require("@datadog/browser-core");
const waitPageActivityEnd_1 = require("../../waitPageActivityEnd");
const rawRumEvent_types_1 = require("../../../rawRumEvent.types");
const trackFirstHidden_1 = require("./trackFirstHidden");
/**
 * For non-initial views (such as route changes or BFCache restores), the regular load event does not fire
 * In these cases, trackLoadingTime can only emit a loadingTime  if waitPageActivityEnd detects some post-restore activity.
 * If nothing happens after the view starts,no candidate is recorded and loadingTime stays undefined.
 */
function trackLoadingTime(lifeCycle, domMutationObservable, windowOpenObservable, configuration, loadType, viewStart, callback) {
    let isWaitingForLoadEvent = loadType === rawRumEvent_types_1.ViewLoadingType.INITIAL_LOAD;
    let isWaitingForActivityLoadingTime = true;
    const loadingTimeCandidates = [];
    const firstHidden = (0, trackFirstHidden_1.trackFirstHidden)(configuration, viewStart);
    function invokeCallbackIfAllCandidatesAreReceived() {
        if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {
            const loadingTime = Math.max(...loadingTimeCandidates);
            // firstHidden is a relative time from time origin, so we use the relative start time of the view to compare with the loading time
            if (loadingTime < firstHidden.timeStamp - viewStart.relative) {
                callback(loadingTime);
            }
        }
    }
    const { stop } = (0, waitPageActivityEnd_1.waitPageActivityEnd)(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (event) => {
        if (isWaitingForActivityLoadingTime) {
            isWaitingForActivityLoadingTime = false;
            if (event.hadActivity) {
                loadingTimeCandidates.push((0, browser_core_1.elapsed)(viewStart.timeStamp, event.end));
            }
            invokeCallbackIfAllCandidatesAreReceived();
        }
    });
    return {
        stop: () => {
            stop();
            firstHidden.stop();
        },
        setLoadEvent: (loadEvent) => {
            if (isWaitingForLoadEvent) {
                isWaitingForLoadEvent = false;
                loadingTimeCandidates.push(loadEvent);
                invokeCallbackIfAllCandidatesAreReceived();
            }
        },
    };
}
//# sourceMappingURL=trackLoadingTime.js.map