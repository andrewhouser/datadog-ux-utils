"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.THROTTLE_SCROLL_DURATION = void 0;
exports.trackScrollMetrics = trackScrollMetrics;
exports.computeScrollValues = computeScrollValues;
exports.createScrollValuesObservable = createScrollValuesObservable;
const browser_core_1 = require("@datadog/browser-core");
const scroll_1 = require("../../../browser/scroll");
const viewportObservable_1 = require("../../../browser/viewportObservable");
/** Arbitrary scroll throttle duration */
exports.THROTTLE_SCROLL_DURATION = browser_core_1.ONE_SECOND;
function trackScrollMetrics(configuration, viewStart, callback, scrollValues = createScrollValuesObservable(configuration)) {
    let maxScrollDepth = 0;
    let maxScrollHeight = 0;
    let maxScrollHeightTime = 0;
    const subscription = scrollValues.subscribe(({ scrollDepth, scrollTop, scrollHeight }) => {
        let shouldUpdate = false;
        if (scrollDepth > maxScrollDepth) {
            maxScrollDepth = scrollDepth;
            shouldUpdate = true;
        }
        if (scrollHeight > maxScrollHeight) {
            maxScrollHeight = scrollHeight;
            const now = (0, browser_core_1.relativeNow)();
            maxScrollHeightTime = (0, browser_core_1.elapsed)(viewStart.relative, now);
            shouldUpdate = true;
        }
        if (shouldUpdate) {
            callback({
                maxDepth: Math.min(maxScrollDepth, maxScrollHeight),
                maxDepthScrollTop: scrollTop,
                maxScrollHeight,
                maxScrollHeightTime,
            });
        }
    });
    return {
        stop: () => subscription.unsubscribe(),
    };
}
function computeScrollValues() {
    const scrollTop = (0, scroll_1.getScrollY)();
    const { height } = (0, viewportObservable_1.getViewportDimension)();
    const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight);
    const scrollDepth = Math.round(height + scrollTop);
    return {
        scrollHeight,
        scrollDepth,
        scrollTop,
    };
}
function createScrollValuesObservable(configuration, throttleDuration = exports.THROTTLE_SCROLL_DURATION) {
    return new browser_core_1.Observable((observable) => {
        function notify() {
            observable.notify(computeScrollValues());
        }
        if (window.ResizeObserver) {
            const throttledNotify = (0, browser_core_1.throttle)(notify, throttleDuration, {
                leading: false,
                trailing: true,
            });
            const observerTarget = document.scrollingElement || document.documentElement;
            const resizeObserver = new ResizeObserver((0, browser_core_1.monitor)(throttledNotify.throttled));
            if (observerTarget) {
                resizeObserver.observe(observerTarget);
            }
            const eventListener = (0, browser_core_1.addEventListener)(configuration, window, "scroll" /* DOM_EVENT.SCROLL */, throttledNotify.throttled, {
                passive: true,
            });
            return () => {
                throttledNotify.cancel();
                resizeObserver.disconnect();
                eventListener.stop();
            };
        }
    });
}
//# sourceMappingURL=trackScrollMetrics.js.map