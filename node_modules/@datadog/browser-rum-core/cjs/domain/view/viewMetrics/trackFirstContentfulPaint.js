"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FCP_MAXIMUM_DELAY = void 0;
exports.trackFirstContentfulPaint = trackFirstContentfulPaint;
exports.trackRestoredFirstContentfulPaint = trackRestoredFirstContentfulPaint;
const browser_core_1 = require("@datadog/browser-core");
const performanceObservable_1 = require("../../../browser/performanceObservable");
// Discard FCP timings above a certain delay to avoid incorrect data
// It happens in some cases like sleep mode or some browser implementations
exports.FCP_MAXIMUM_DELAY = 10 * browser_core_1.ONE_MINUTE;
function trackFirstContentfulPaint(configuration, firstHidden, callback) {
    const performanceSubscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: performanceObservable_1.RumPerformanceEntryType.PAINT,
        buffered: true,
    }).subscribe((entries) => {
        const fcpEntry = entries.find((entry) => entry.name === 'first-contentful-paint' &&
            entry.startTime < firstHidden.timeStamp &&
            entry.startTime < exports.FCP_MAXIMUM_DELAY);
        if (fcpEntry) {
            callback(fcpEntry.startTime);
        }
    });
    return {
        stop: performanceSubscription.unsubscribe,
    };
}
/**
 * Measure the First Contentful Paint after a BFCache restoration.
 * The DOM is restored synchronously, so we approximate the FCP with the first frame
 * rendered just after the pageshow event, using two nested requestAnimationFrame calls.
 */
function trackRestoredFirstContentfulPaint(viewStartRelative, callback) {
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            callback((0, browser_core_1.elapsed)(viewStartRelative, (0, browser_core_1.relativeNow)()));
        });
    });
}
//# sourceMappingURL=trackFirstContentfulPaint.js.map