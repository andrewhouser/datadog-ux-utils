"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MEASURES_PERIOD_DURATION = void 0;
exports.startCustomerDataTelemetry = startCustomerDataTelemetry;
const browser_core_1 = require("@datadog/browser-core");
exports.MEASURES_PERIOD_DURATION = 10 * browser_core_1.ONE_SECOND;
let currentPeriodMeasures;
let batchHasRumEvent;
function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, batchFlushObservable) {
    const customerDataTelemetryEnabled = telemetry.enabled && (0, browser_core_1.performDraw)(configuration.customerDataTelemetrySampleRate);
    if (!customerDataTelemetryEnabled) {
        return;
    }
    initCurrentPeriodMeasures();
    batchHasRumEvent = false;
    // We measure the data of every view updates even if there could only be one per batch due to the upsert
    // It means that contexts bytes count sums can be higher than it really is
    lifeCycle.subscribe(13 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, () => {
        batchHasRumEvent = true;
    });
    batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {
        // Don't measure batch that only contains telemetry events to avoid batch sending loop
        // It could happen because after each batch we are adding a customer data measures telemetry event to the next one
        if (!batchHasRumEvent) {
            return;
        }
        batchHasRumEvent = false;
        currentPeriodMeasures.batchCount += 1;
        updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);
        updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);
    });
    (0, browser_core_1.setInterval)(sendCurrentPeriodMeasures, exports.MEASURES_PERIOD_DURATION);
}
function sendCurrentPeriodMeasures() {
    if (currentPeriodMeasures.batchCount === 0) {
        return;
    }
    (0, browser_core_1.addTelemetryMetrics)('Customer data measures', currentPeriodMeasures);
    initCurrentPeriodMeasures();
}
function createMeasure() {
    return { min: Infinity, max: 0, sum: 0 };
}
function updateMeasure(measure, value) {
    measure.sum += value;
    measure.min = Math.min(measure.min, value);
    measure.max = Math.max(measure.max, value);
}
function initCurrentPeriodMeasures() {
    currentPeriodMeasures = {
        batchCount: 0,
        batchBytesCount: createMeasure(),
        batchMessagesCount: createMeasure(),
    };
}
//# sourceMappingURL=startCustomerDataTelemetry.js.map