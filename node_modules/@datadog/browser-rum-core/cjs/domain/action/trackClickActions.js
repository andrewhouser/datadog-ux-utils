"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ACTION_CONTEXT_TIME_OUT_DELAY = void 0;
exports.trackClickActions = trackClickActions;
exports.finalizeClicks = finalizeClicks;
const browser_core_1 = require("@datadog/browser-core");
const rawRumEvent_types_1 = require("../../rawRumEvent.types");
const trackEventCounts_1 = require("../trackEventCounts");
const waitPageActivityEnd_1 = require("../waitPageActivityEnd");
const getSelectorFromElement_1 = require("../getSelectorFromElement");
const privacy_1 = require("../privacy");
const clickChain_1 = require("./clickChain");
const getActionNameFromElement_1 = require("./getActionNameFromElement");
const listenActionEvents_1 = require("./listenActionEvents");
const computeFrustration_1 = require("./computeFrustration");
const interactionSelectorCache_1 = require("./interactionSelectorCache");
exports.ACTION_CONTEXT_TIME_OUT_DELAY = 5 * browser_core_1.ONE_MINUTE; // arbitrary
function trackClickActions(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {
    const history = (0, browser_core_1.createValueHistory)({ expireDelay: exports.ACTION_CONTEXT_TIME_OUT_DELAY });
    const stopObservable = new browser_core_1.Observable();
    let currentClickChain;
    lifeCycle.subscribe(10 /* LifeCycleEventType.SESSION_RENEWED */, () => {
        history.reset();
    });
    lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, stopClickChain);
    lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, (event) => {
        if (event.reason === browser_core_1.PageExitReason.UNLOADING) {
            stopClickChain();
        }
    });
    const { stop: stopActionEventsListener } = (0, listenActionEvents_1.listenActionEvents)(configuration, {
        onPointerDown: (pointerDownEvent) => processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable),
        onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) => {
            startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);
        },
    });
    const actionContexts = {
        findActionId: (startTime) => history.findAll(startTime),
    };
    return {
        stop: () => {
            stopClickChain();
            stopObservable.notify();
            stopActionEventsListener();
        },
        actionContexts,
    };
    function appendClickToClickChain(click) {
        if (!currentClickChain || !currentClickChain.tryAppend(click)) {
            const rageClick = click.clone();
            currentClickChain = (0, clickChain_1.createClickChain)(click, (clicks) => {
                finalizeClicks(clicks, rageClick);
            });
        }
    }
    function stopClickChain() {
        if (currentClickChain) {
            currentClickChain.stop();
        }
    }
}
function processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent, windowOpenObservable) {
    const nodePrivacyLevel = configuration.enablePrivacyForActionName
        ? (0, privacy_1.getNodePrivacyLevel)(pointerDownEvent.target, configuration.defaultPrivacyLevel)
        : privacy_1.NodePrivacyLevel.ALLOW;
    if (nodePrivacyLevel === privacy_1.NodePrivacyLevel.HIDDEN) {
        return undefined;
    }
    const clickActionBase = computeClickActionBase(pointerDownEvent, nodePrivacyLevel, configuration);
    let hadActivityOnPointerDown = false;
    (0, waitPageActivityEnd_1.waitPageActivityEnd)(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (pageActivityEndEvent) => {
        hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;
    }, 
    // We don't care about the activity duration, we just want to know whether an activity did happen
    // within the "validation delay" or not. Limit the duration so the callback is called sooner.
    waitPageActivityEnd_1.PAGE_ACTIVITY_VALIDATION_DELAY);
    return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown };
}
function startClickAction(configuration, lifeCycle, domMutationObservable, windowOpenObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {
    var _a;
    const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);
    appendClickToClickChain(click);
    const selector = (_a = clickActionBase === null || clickActionBase === void 0 ? void 0 : clickActionBase.target) === null || _a === void 0 ? void 0 : _a.selector;
    if (selector) {
        (0, interactionSelectorCache_1.updateInteractionSelector)(startEvent.timeStamp, selector);
    }
    const { stop: stopWaitPageActivityEnd } = (0, waitPageActivityEnd_1.waitPageActivityEnd)(lifeCycle, domMutationObservable, windowOpenObservable, configuration, (pageActivityEndEvent) => {
        if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {
            // If the clock is looking weird, just discard the click
            click.discard();
        }
        else {
            if (pageActivityEndEvent.hadActivity) {
                click.stop(pageActivityEndEvent.end);
            }
            else if (hadActivityOnPointerDown()) {
                click.stop(
                // using the click start as activity end, so the click will have some activity but its
                // duration will be 0 (as the activity started before the click start)
                click.startClocks.timeStamp);
            }
            else {
                click.stop();
            }
        }
    }, interactionSelectorCache_1.CLICK_ACTION_MAX_DURATION);
    const viewEndedSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, ({ endClocks }) => {
        click.stop(endClocks.timeStamp);
    });
    const stopSubscription = stopObservable.subscribe(() => {
        click.stop();
    });
    click.stopObservable.subscribe(() => {
        viewEndedSubscription.unsubscribe();
        stopWaitPageActivityEnd();
        stopSubscription.unsubscribe();
    });
}
function computeClickActionBase(event, nodePrivacyLevel, configuration) {
    const rect = event.target.getBoundingClientRect();
    const selector = (0, getSelectorFromElement_1.getSelectorFromElement)(event.target, configuration.actionNameAttribute);
    if (selector) {
        (0, interactionSelectorCache_1.updateInteractionSelector)(event.timeStamp, selector);
    }
    const actionName = (0, getActionNameFromElement_1.getActionNameFromElement)(event.target, configuration, nodePrivacyLevel);
    return {
        type: rawRumEvent_types_1.ActionType.CLICK,
        target: {
            width: Math.round(rect.width),
            height: Math.round(rect.height),
            selector,
        },
        position: {
            // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element
            x: Math.round(event.clientX - rect.left),
            y: Math.round(event.clientY - rect.top),
        },
        name: actionName.name,
        nameSource: actionName.nameSource,
    };
}
function newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {
    const id = (0, browser_core_1.generateUUID)();
    const startClocks = (0, browser_core_1.clocksNow)();
    const historyEntry = history.add(id, startClocks.relative);
    const eventCountsSubscription = (0, trackEventCounts_1.trackEventCounts)({
        lifeCycle,
        isChildEvent: (event) => event.action !== undefined &&
            (Array.isArray(event.action.id) ? event.action.id.includes(id) : event.action.id === id),
    });
    let status = 0 /* ClickStatus.ONGOING */;
    let activityEndTime;
    const frustrationTypes = [];
    const stopObservable = new browser_core_1.Observable();
    function stop(newActivityEndTime) {
        if (status !== 0 /* ClickStatus.ONGOING */) {
            return;
        }
        activityEndTime = newActivityEndTime;
        status = 1 /* ClickStatus.STOPPED */;
        if (activityEndTime) {
            historyEntry.close((0, browser_core_1.getRelativeTime)(activityEndTime));
        }
        else {
            historyEntry.remove();
        }
        eventCountsSubscription.stop();
        stopObservable.notify();
    }
    return {
        event: startEvent,
        stop,
        stopObservable,
        get hasError() {
            return eventCountsSubscription.eventCounts.errorCount > 0;
        },
        get hasPageActivity() {
            return activityEndTime !== undefined;
        },
        getUserActivity,
        addFrustration: (frustrationType) => {
            frustrationTypes.push(frustrationType);
        },
        startClocks,
        isStopped: () => status === 1 /* ClickStatus.STOPPED */ || status === 2 /* ClickStatus.FINALIZED */,
        clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),
        validate: (domEvents) => {
            stop();
            if (status !== 1 /* ClickStatus.STOPPED */) {
                return;
            }
            const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts;
            const clickAction = {
                duration: activityEndTime && (0, browser_core_1.elapsed)(startClocks.timeStamp, activityEndTime),
                startClocks,
                id,
                frustrationTypes,
                counts: {
                    resourceCount,
                    errorCount,
                    longTaskCount,
                },
                events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],
                event: startEvent,
                ...clickActionBase,
            };
            lifeCycle.notify(0 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, clickAction);
            status = 2 /* ClickStatus.FINALIZED */;
        },
        discard: () => {
            stop();
            status = 2 /* ClickStatus.FINALIZED */;
        },
    };
}
function finalizeClicks(clicks, rageClick) {
    const { isRage } = (0, computeFrustration_1.computeFrustration)(clicks, rageClick);
    if (isRage) {
        clicks.forEach((click) => click.discard());
        rageClick.stop((0, browser_core_1.timeStampNow)());
        rageClick.validate(clicks.map((click) => click.event));
    }
    else {
        rageClick.discard();
        clicks.forEach((click) => click.validate());
    }
}
//# sourceMappingURL=trackClickActions.js.map