"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXCLUDED_MUTATIONS_ATTRIBUTE = exports.PAGE_ACTIVITY_END_DELAY = exports.PAGE_ACTIVITY_VALIDATION_DELAY = void 0;
exports.waitPageActivityEnd = waitPageActivityEnd;
exports.doWaitPageActivityEnd = doWaitPageActivityEnd;
exports.createPageActivityObservable = createPageActivityObservable;
const browser_core_1 = require("@datadog/browser-core");
const performanceObservable_1 = require("../browser/performanceObservable");
const htmlDomUtils_1 = require("../browser/htmlDomUtils");
// Delay to wait for a page activity to validate the tracking process
exports.PAGE_ACTIVITY_VALIDATION_DELAY = 100;
// Delay to wait after a page activity to end the tracking process
exports.PAGE_ACTIVITY_END_DELAY = 100;
exports.EXCLUDED_MUTATIONS_ATTRIBUTE = 'data-dd-excluded-activity-mutations';
/**
 * Wait for the page activity end
 *
 * Detection lifecycle:
 * ```
 *                        Wait page activity end
 *              .-------------------'--------------------.
 *              v                                        v
 *     [Wait for a page activity ]          [Wait for a maximum duration]
 *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]
 *          /                  \                           |
 *         v                    v                          |
 *  [No page activity]   [Page activity]                   |
 *         |                   |,----------------------.   |
 *         v                   v                       |   |
 *     (Discard)     [Wait for a page activity]        |   |
 *                   [   timeout: END_DELAY   ]        |   |
 *                       /                \            |   |
 *                      v                  v           |   |
 *             [No page activity]    [Page activity]   |   |
 *                      |                 |            |   |
 *                      |                 '------------'   |
 *                      '-----------. ,--------------------'
 *                                   v
 *                                 (End)
 * ```
 *
 * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the
 * process is still alive after maxDuration, it has been validated.
 */
function waitPageActivityEnd(lifeCycle, domMutationObservable, windowOpenObservable, configuration, pageActivityEndCallback, maxDuration) {
    const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration);
    return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);
}
function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {
    let pageActivityEndTimeoutId;
    let hasCompleted = false;
    const validationTimeoutId = (0, browser_core_1.setTimeout)((0, browser_core_1.monitor)(() => complete({ hadActivity: false })), exports.PAGE_ACTIVITY_VALIDATION_DELAY);
    const maxDurationTimeoutId = maxDuration !== undefined
        ? (0, browser_core_1.setTimeout)((0, browser_core_1.monitor)(() => complete({ hadActivity: true, end: (0, browser_core_1.timeStampNow)() })), maxDuration)
        : undefined;
    const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {
        (0, browser_core_1.clearTimeout)(validationTimeoutId);
        (0, browser_core_1.clearTimeout)(pageActivityEndTimeoutId);
        const lastChangeTime = (0, browser_core_1.timeStampNow)();
        if (!isBusy) {
            pageActivityEndTimeoutId = (0, browser_core_1.setTimeout)((0, browser_core_1.monitor)(() => complete({ hadActivity: true, end: lastChangeTime })), exports.PAGE_ACTIVITY_END_DELAY);
        }
    });
    const stop = () => {
        hasCompleted = true;
        (0, browser_core_1.clearTimeout)(validationTimeoutId);
        (0, browser_core_1.clearTimeout)(pageActivityEndTimeoutId);
        (0, browser_core_1.clearTimeout)(maxDurationTimeoutId);
        pageActivitySubscription.unsubscribe();
    };
    function complete(event) {
        if (hasCompleted) {
            return;
        }
        stop();
        pageActivityEndCallback(event);
    }
    return { stop };
}
function createPageActivityObservable(lifeCycle, domMutationObservable, windowOpenObservable, configuration) {
    return new browser_core_1.Observable((observable) => {
        const subscriptions = [];
        let firstRequestIndex;
        let pendingRequestsCount = 0;
        subscriptions.push(domMutationObservable.subscribe((mutations) => {
            if (!mutations.every(isExcludedMutation)) {
                notifyPageActivity();
            }
        }), windowOpenObservable.subscribe(notifyPageActivity), (0, performanceObservable_1.createPerformanceObservable)(configuration, { type: performanceObservable_1.RumPerformanceEntryType.RESOURCE }).subscribe((entries) => {
            if (entries.some((entry) => !isExcludedUrl(configuration, entry.name))) {
                notifyPageActivity();
            }
        }), lifeCycle.subscribe(7 /* LifeCycleEventType.REQUEST_STARTED */, (startEvent) => {
            if (isExcludedUrl(configuration, startEvent.url)) {
                return;
            }
            if (firstRequestIndex === undefined) {
                firstRequestIndex = startEvent.requestIndex;
            }
            pendingRequestsCount += 1;
            notifyPageActivity();
        }), lifeCycle.subscribe(8 /* LifeCycleEventType.REQUEST_COMPLETED */, (request) => {
            if (isExcludedUrl(configuration, request.url) ||
                firstRequestIndex === undefined ||
                // If the request started before the tracking start, ignore it
                request.requestIndex < firstRequestIndex) {
                return;
            }
            pendingRequestsCount -= 1;
            notifyPageActivity();
        }));
        return () => {
            subscriptions.forEach((s) => s.unsubscribe());
        };
        function notifyPageActivity() {
            observable.notify({ isBusy: pendingRequestsCount > 0 });
        }
    });
}
function isExcludedUrl(configuration, requestUrl) {
    return (0, browser_core_1.matchList)(configuration.excludedActivityUrls, requestUrl);
}
function isExcludedMutation(mutation) {
    const targetElement = mutation.type === 'characterData' ? mutation.target.parentElement : mutation.target;
    return Boolean(targetElement &&
        (0, htmlDomUtils_1.isElementNode)(targetElement) &&
        targetElement.matches(`[${exports.EXCLUDED_MUTATIONS_ATTRIBUTE}], [${exports.EXCLUDED_MUTATIONS_ATTRIBUTE}] *`));
}
//# sourceMappingURL=waitPageActivityEnd.js.map